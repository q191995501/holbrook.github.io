<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>心内求法</title>
  
  <subtitle>Holbrook的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://holbrook.github.io/"/>
  <updated>2017-10-26T10:54:39.000Z</updated>
  <id>http://holbrook.github.io/</id>
  
  <author>
    <name>Holbrook</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/quantitative_investment13.html"/>
    <id>http://holbrook.github.io/2017/10/26/quantitative_investment13.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>第13章 统计套利策略的挖掘与优化</p><p>13.1 统计套利策略概述<br>13.1.1 统计套利的定义<br>13.1.2 统计套利策略的基本思想<br>13.1.3 统计套利策略挖掘的方法<br>13.2 基本策略的挖掘<br>13.2.1 准备数据<br>13.2.2 探索交易策略<br>13.2.3 验证交易策略<br>13.2.4 选择最佳的参数<br>13.2.5 参数扫描法<br>13.2.6 考虑交易费<br>13.3 高频交易策略及优化<br>13.3.1 高频交易的基本思想<br>13.3.2 高频交易的实现<br>13.4 多交易信号策略的组合及优化<br>13.4.1 多交易信号策略<br>13.4.2 交易信号的组合优化机理<br>13.4.3 交易信号的组合优化实现<br>13.5 本章小结<br>参考文献</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第13章 统计套利策略的挖掘与优化&lt;/p&gt;
&lt;p&gt;13.1 统计套利策略概述&lt;br&gt;13.1.1 统计套利的定义&lt;br&gt;13.1.2 统计套利策略的基本思想&lt;br&gt;13.1.3 统计套利策略挖掘的方法&lt;br&gt;13.2 基本策略的挖掘&lt;br&gt;13.2.1 准备数据&lt;br&gt;13
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/about_quant_platform.html"/>
    <id>http://holbrook.github.io/2017/10/26/about_quant_platform.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="量化交易平台要解决的问题"><a href="#量化交易平台要解决的问题" class="headerlink" title="量化交易平台要解决的问题"></a>量化交易平台要解决的问题</h1><p>量化交易最终要实现一个可以运行的策略。大体上可以研究阶段和运行阶段。</p><p>在研究阶段，需要</p><ol><li>研究</li><li>试运行</li><li>运行和监测</li></ol><p>研究平台</p><p>交易平台</p><h1 id="已有平台"><a href="#已有平台" class="headerlink" title="已有平台"></a>已有平台</h1><p>原创：<br><a href="https://www.quantopian.com/" target="_blank" rel="external">Quantopian</a></p><p><a href="http://www.zipline.io/index.html" target="_blank" rel="external">zipline</a><br>一个开源回测框架<br>配置一个在本地玩儿<br>还不怕策略被偷</p><p>国外：<br><a href="http://www.quantpedia.com/" target="_blank" rel="external">quantpedia</a> ?</p><ul><li><p><a href="https://uqer.io/home/" target="_blank" rel="external">优矿(Uqer)</a></p><p>背后是通联数据</p></li><li><p><a href="https://www.ricequant.com" target="_blank" rel="external">米筐(RiceQuant)</a></p></li><li><p><a href="https://www.joinquant.com/" target="_blank" rel="external">聚宽(JoinQuant)</a></p></li><li><p><a href="http://www.myquant.cn/" target="_blank" rel="external">掘金</a></p></li><li><p><a href="http://www.dajiangzhang.com/" target="_blank" rel="external">大奖章</a></p><p>背后是万德</p></li><li><p><a href="https://quant.jd.com/" target="_blank" rel="external">京东量化平台</a></p></li></ul><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><h2 id="API语言支持"><a href="#API语言支持" class="headerlink" title="API语言支持"></a>API语言支持</h2><p>都支持 python<br>RiceQuant 还支持 Java<br>掘金还支持Java，Matlib, R, C/C++, C#<br>大奖章 ？</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>前几天正好利用三家平台分析某些行业股票历史数据。发现如下：<br>1.优矿社区比较活跃，但保存到Data中的数据，一直在载入，就是看不到，无法下载。<br>2.米筐呢，保存的数据，刚开始还可以download，后来就无法下载了。<br>3.目前在用聚宽，但里面的股票财务数据，做的不如优矿和米筐详细。<br>建议可以参照某些财务类书籍，将指标分为运营性、盈利性、成长性、负债性等。</p><p>JoinQuant<br>        数据：免费提供A股行情、财务数据、指数数据、基金数据</p><p>时间周期：<br>tick, 分钟，日线</p><h2 id="开放性"><a href="#开放性" class="headerlink" title="开放性"></a>开放性</h2><p>RiceQuant 的回测框架开源，开放了RQuantAPI</p><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><h2 id="回测"><a href="#回测" class="headerlink" title="回测"></a>回测</h2><p>JoinQuant<br>        支持日级、分钟级回测</p><h2 id="社区和帮助文档"><a href="#社区和帮助文档" class="headerlink" title="社区和帮助文档"></a>社区和帮助文档</h2><p>功能：</p><pre><code>模拟交易    JoinQuant    支持日级、分钟级、tick级模拟交易实盘交易    券商接口：</code></pre><h2 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h2><h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>分享一下在使用过程中的感受：</p><p>优矿：</p><ol><li>数据种类丰富，收费数据可以免费试用</li><li>有活跃的社区（日报我很喜欢哦，如果有动态大图就更破费了）</li><li>前几天推出的快速版和一个简化信号功能，体验了两天，回测速度非常快，爽。</li><li>@楼上匿名用户，我觉得自动补全很好用啊，文档都可以看到，使用DataAPI方便的不行。</li><li>优矿每月都有500万实盘大赛，听说赚了都归我。之前没参赛，打算用简化信号功能开发一个策略参赛玩玩</li><li>history拿历史数据的api太多了。界面体验上没另外两家好，熟悉平台时间也要长一些。</li></ol><p>米筐：</p><ol><li>米筐的founder们是一群具有交易系统气质的大牛，开发实力强劲。</li><li>平台同时支持python和java两种语言的回测。</li><li>米筐的视觉设计和文档做的非常棒，特别是回测结果页面，看着很舒服。</li><li>米筐举办的大赛，已经有两期了，奖品还可以，可惜也没拿到。</li><li>推出功能速度有些慢，后台稳定性有待加强（最近实时模拟交易也关闭了）。</li></ol><p>聚宽：</p><ol><li>开发速度很快，比如撤单，非复权成交等等功能，新功能上线很迅速；</li><li>社区也比较活跃，很多不错的ETF策略</li><li>聚宽没有举办大赛，而是推出了销售策略活动，打算提交一个试试。</li><li>微信推送调仓很好用，期待政府早日放开实盘限制</li><li>回测速度比上面两家慢，有时候会卡死。</li></ol><p>总结：<br>个人目前主要在优矿上玩。在ipython notebook进行完策略研究，直接编写策略，这种一体化的感觉很好，适合我们这种追求完美与极致体验的星座。也经常去聚宽社区，挖掘靠谱思路。米筐体验上很好，但是现在越用越少，希望他们能在功能上努力加油。</p><p>关于回测速度，本猿特意在三个平台分别运行了一个4年HS300按日调仓的日线双均线策略（颤抖吧，人类）回测时间如下：</p><p>UQER RQ JQ<br>hs300双均线 60s 264s 150s</p><p>距离上次写下这个答案也有4个多月了，几家平台都发生了一些变化，说一下新的体会。</p><p>我就列一下各平台4个月来的变化以及新体会吧。</p><ul><li>优矿<ul><li>分钟线回测快了不少，终于可以正常用了</li><li>加上了自动补全，然而连co_code这种都补出来了我会乱说？</li><li>其他变化不大。。</li><li>新体会：<ul><li>深入用过其它两家之后，才发现优矿的API好难用</li><li>history等重要函数存在很久bug的也没修</li><li>财务数据的API在分钟级回测里几乎不可能写对，而且提示信息好乱</li><li>现在已经几乎弃用优矿了，对他们很失望耶。。</li></ul></li></ul></li><li>Ricequant<ul><li>增加了很多数据，比如指数和分级基金等</li><li>现在回测也比较稳定了，感谢进度条。已经支持Python编写回测了</li><li>支持了分钟级的实盘仿真交易</li><li>参加了一次比赛，名落孙山。。。</li><li>新体会：<ul><li>回测速度更快了，应该不是错觉。。</li><li>刚发现财务数据文档好流弊</li><li>log和回测后的交易、仓位列表无法检索（似乎是部分渲染的结果），性能是好了，但是就不好用了</li><li>感人的全量日志随意拖动，不得不说调试起来效率高了很多</li></ul></li></ul></li><li>JoinQuant<ul><li>支持了分钟级数据的实盘仿真交易，不过数据是比实盘延迟了一分钟</li><li>实盘模拟中的微信通知功能简直搔到痒处</li><li>跟Riequant一样增加了很多数据</li><li>还有一些奇奇怪怪的小功能比如性能分析（反正我不会用。。）</li><li>新体会：<ul><li>API总体来说用起来和Quantopian类似，很容易上手</li><li>居然没有调仓神器order_target_percent？</li><li>API的命名比较随意，从API设计来看似乎并未经过深思熟虑,如:<ul><li>portfolio.unsell_positions[id]：英文语法上这是一个动宾结构，如果代表“无法卖出的仓位”，<br>应该用frozen_positions。对比Ricequant的类似功能是portfolio.position[id].sellable，直接获得可以卖出的仓位，平仓时更好用。</li><li>starting_cash和capital_used，两者都代表现金，但一个用了cash，一个用了capital，且顺序不一样。<br>后一个改成used_cash比较好。</li><li>order.add_time：这个又是一个语法上的动宾结构，不知所谓。<br>如果代表创建时间，应该用creation_time更好，相应后来会有modification_time, cancellation_time。<br>如果觉得太长，就用created_time, modified_time, canceled_time，add_time直译的确是“添加时间”，<br>然而这是中式英语。</li><li>run_weekly参数中的weekday：这个在英文代表的是星期的意思，如果是weekday，对应的是Monday, Tuesday这些，然而看API描述对应的是Quantopian的offset，不如直接用offset。</li></ul></li></ul></li></ul></li></ul><ul><li><p>对比</p><p>我觉得功能和体验上优矿已经落后了，企业版的我没用过<br>Ricequant的API比JoinQuant的好用，也更清爽，如果能加入微信提醒功能就好了。</p></li></ul><p>我两边都有用过，作为一个业余人士，不知道谁比较强，只说个人感受。</p><p>功能上的总结：</p><ul><li>优矿<ul><li>背靠通联引入了海量数据</li><li>IPython Notebook与回测引擎的整合可以做一些参数优化的东西，这点非常重要</li><li>支持分钟线回测及日数据仿真交易（每天两次收盘时触发一个事件）</li><li>CAL库支持了不少常用的不常用的金融算法</li><li>可自定义library，复用自己的模块</li></ul></li><li>Ricequant<ul><li>只有股票及ETF的交易数据和财务数据，不过一般也够用了</li><li>同时支持Java及Python的回测引擎</li><li>结果展示上丰富一些</li><li>速度超快，可能是因为是Java的关系（Python也很快，据说只是在Java上包了个壳）</li><li>长得好<br>各自的缺点：</li></ul></li><li>优矿<ul><li>回测速度较慢。分钟线回测的速度基本上不能忍，我一次都没有成功过（可能是因为太慢导致session判断超时？）</li><li>数据来源及如何洗刷上没有解释，我用的时候只能相信或者不信</li><li>回测的api有点绕</li></ul></li><li>Ricequant<ul><li>网速差的时候经常回测结果跑不出来</li><li>好像其他没什么了。。就是功能少了点</li></ul></li></ul><p>个人认为优矿的运营很接地气，但是产品细节并不亲民（功能是多了，但是比如分钟线回测真的是然并卵啊，日数据仿真有意义吗）；<br>而Ricequant正好相反，感觉是一群比较踏实的人吧。</p><p>至于JoinQuant，我近期才注册，随便玩了一下。然而必须吐个槽。。</p><p>数月前第一次看到Ricequant时我第一反应就是，我去，抄得真像。然后看到了joinquant。<br>发现Ricequant的界面真是诚意之作——抄的是交互设计，视觉设计完全不一样；后来看到了论坛的改版，简直惊艳。</p><p>另外JoinQuant连API设计都是像素级拷贝（除了去掉了initialize）。<br>是为了直接复制黏贴即可使用Quantopian的策略？</p><p>当然，JoinQuant现在支持分钟线及每日数据回测，而且速度很快（目测甚至快过Quantopian）。<br>同样是Python的平台（不知道后台是不是也用了Python写），性能也是有本质差距的。</p><p>我没有深入JoinQuant，不过看文档他们似乎只有基本的交易行情数据，跟前面两家平台还是有一定差距。<br>但是就他们的技术能力来说，我认为还是很有潜力的。等哪天追上了再关注一下。</p><hr><p>题主说的这三家我都用过，但是个人感觉最强的应该是掘金！</p><p>首先说聚宽，那是我最先用的量化平台，也是目前的主力平台，优点是支持微信提醒，这点非常重要！可以自己设置股价是否复权（貌似三家里就他家暂时可以？）对于一些时间段较长的回测还是不错的。缺点是回测速度只有一般，时快时慢，不过好在大部分时间能用，api 相对较少，数据的话也不是很全，比如目前的基本面数据就找不到关于企业分红的信息。</p><p>然后是米框，这个平台本来打算做备胎的，不过网站用起来太别扭，所以被踢掉了。<br>优点是 数据很全，公司的基本面信息齐全，你想到的没想到的他都提供给你了，网站本身提供的 api 也相当丰富，尤其是那几个 order_xxx 的函数，非常实用，相当赞！ 支持 java 编写策略应该也算一大优点吧？<br>缺点暂时不明，因为网站用起来别扭，所以我用的不多。</p><p>接着是优矿，通联数据开的，优点很明显，数据齐全，毕竟通联数据就是干这个的。<br>缺点嘛，api 设置的太渣了，估计是经手的人太多，乱七八糟的驼峰，有些全称，有些简写，尼玛关键是数量多，看的头大，用起来也麻烦，我反正是被那一堆 api 吓跑的。</p><p>最后我要说掘金，为什么我认为目前他是最强的？因为以上三个都是在线平台，你所有的策略都要放在他们平台，安全性什么的就看平台道德了。</p><p>而掘金的策略都存放在本地！存放在本地！存放在本地！至少策略安全性上比上面三个高一大截！而且由于是运行在本地环境，可定制性是上面几个平台无法比拟的，比如我用 python 编写策略，上面三个平台都不允许策略访问网络，掘金完全没这个问题，要用什么库自己加！</p><p>不过缺点也很明显，策略编写复杂，比上面三个要复杂不少，而且文档写的也不够浅显易懂，不是有经验的码农基本用不了。而且社区是上面三个平台里最不活跃的，要不是他们经常更新 SDK 我一度以为他们已经不干了（大概主要精力放在企业版上了-v-）</p><p>而且只支持 window 跟 linux 平台，osx 用户就只能玩蛋去了（已经向他们反馈多次，始终没有回应）-，-</p><p>不过由于本地运行的优点，我还是最关注他们。。。</p><p>单纯以现阶段的研究工具来说感觉：<br>优矿：数据充分。但是用起来总是感觉比较慢（？），Notebook与策略回测整合的很好。AI部分似乎没有深度计算部分（聚宽和米框都有），可以加上。社区活跃度较高。<br>聚宽：熟了之后很爽，数据够用，非常灵活。<br>米框：研究的时候用起来比聚宽还爽，社区也不错。</p><p>这三个都是很好的研究工具，优矿适合入门，聚宽米框适合有点经验的研究者。这种开放平台，后续的发展，个人感觉在社区活跃度、开放度、生态系统构建上。</p><p>个人用过joinquant和ricequant，只说这两个到比较。<br>joinquant：开发速度特别快，对于社区和群里面反映的问题响应非常迅速，开发实力强劲。回测速度比ricequant快太多，数据处理的较好，文档详尽。不过不支持java，网站看起来比较高冷，有一些小bug。<br>ricequant：刚开始用的原因是支持java，页面制作的比较有意思，看起来有亲和力，回测过程中能够一直看到风险数据的变化。不过回测速度比较慢，同时回测的策略太少，数据有小问题（有个策略跑到一半出错了，多次尝试都这样）。整体框架设计没有joinquant好用，文档没有joinquant好用。</p><p>作为初学者，感觉米框很不错 确实没人 但是整个平台数据什么都是免费 教学贴也越来越丰富 可能以后进阶了会看看其他平台但是现阶段还是顶米框 希望能越做越好</p><p>我用同样的期货策略在米筐和优矿上跑了一下发现结果差距好大，然后在vnpy上跑了一下发现差距更大了。然后就被水淹没不知所措了…</p><p>对于小白来说可能米矿更好一点吧 感觉他上面的教学比优矿做的好</p><p>我觉的ricequant上面有python和java两种方式写策略，很不错，反正就是学习玩玩（相信online的模式以后肯定是趋势），日常数据还是来自wind，分析用matlab，策略用python</p><p>不得不吐槽下ricequant, 类似某米牌手机，扩张快，数据质量小问题很多。</p><p>因为uqer没有2010之前的分钟数据，转到ricquant.<br>但是屡屡踩雷啊：分钟数据和日线数据不在一个频道，停牌时分钟有时填充有时不填充，有的分钟数据是前一天的。。。<br>为了这个，真是额外多花了一倍的调试时间；还不知道埋了多少雷。</p><p>rq起步晚，工作人员比uq少，服务态度也就跟不上。</p><p>客观的看论坛活跃用户，rq不及uq十分之一，慎入！！！</p><h1 id="量化平台的发展"><a href="#量化平台的发展" class="headerlink" title="量化平台的发展"></a>量化平台的发展</h1><p>目前高票匿名用户完全搞错了这两个平台的用途。</p><p>首先本身量化交易由于交易市场的特殊性，不存在和其他行业一样竞争越激烈越有可能使整个社会全面进步，<br>而是一个人只要有能盈利的策略就可以稳割韭菜。</p><p>所以这种平台是为了干什么呢？肯定是为了吸引用户啊……吸引用户是干什么呢？<br>肯定不是为了找最优策略吧……大家都是小怪，碰撞不出什么高端策略……</p><p>说白了以后肯定要利用媒体等商业模式变现啊，所以这两个都是社交平台呀。</p><p>量化是投资的未来，数据是量化的基础，即使暂时低潮，<br>基于大数据和AI的量化投资也终将成为市场主导的力量。</p><p>商业模式：</p><p>先从工具下手，到社区到众筹策略hedge fund</p><p>先抛观点：一直不看好所谓的量化平台，原因是这并不是一个好的商业模式</p><p>首先，用户定位问题<br>现在的量化平台主要定位于中低端客户，比如各类学生。那么从客户定位来说就处于一个很尴尬的地位，因为你是不能随着客户成长而成长的。因为如果客户足够专业，那么他一定会自己搞系统，并不会使用你的量化平台，而且从专业能力上他们自己的能力也强于你们这些做量化平台的，所以他们的选择一定是自建。因此，你的客户群体永远只能定位于中低端用户。那么问题来了，金融行业是一个赢者通吃，贫富差距特别明显的行业。中低端用户本来就没有钱，收入少，你就很难再从他们身上赚钱，而当他们开始挣钱了，又会慢慢脱离你的平台，你也挣不到他们的钱，所以为什么我说这并不是一个好的商业模式。</p><p>其次，安全性的问题<br>其实很多回答已经涉及到这方面了，量化投资和主动投资不同。你的脑子是黑箱，但是你的代码不是，所以量化的人特别注意安全性的问题。不管你平台再怎么解释，可是事实不是你有没有，是你的用户相信你有没有。我举一个例子来说明这个问题，有一个业内大佬刚出来做私募的时候，我问他对通联的看法，他的原话是通联和我很熟，他们邀请我过去提供给我做私募需要的一切，包括办公场地，拎包入住，但是我哪里敢。当时他正好在公司最困难的时期，现在已经成为了国内一线的量化对冲基金，当时那么困难的情况下不会，现在恐怕更不会了。他当时的表态也说明了很多人的看法，不管我怎么困难，安全性是我受要考虑的问题，而量化平台并不能给我这个信心。对于做量化的人来说需要很多it支持，我可以用阿里云的主机或者用github把所有的代码放在上面，因为我觉得你们就是做这个服务的，不会针对我。但是我不敢把自己的核心东西交给你们这些量化平台，正是因为你们懂这些，何况你们下面还有自己的投资公司（比如通联下面的桐昇通惠），这个必须有利益冲突，我怎么知道你会怎么处理，就算说的再好听我也不敢冒这个险，何况在国内的商业环境下。</p><p>那么是不是量化平台不能做了呢？非也，我觉得在两块还是可以有所做和有所需求的<br>第一块是数据接口<br>我不需要提供什么在线编程，大家最需要的必需品是数据，我有很好的数据接口可以让我用方便的模式调取各种数据就ok了。并且数据这块也是最有粘性的东西，如果你再有一些特别的数据就更好了，这个就是BATJ的优势了。当然这个数据接口核心在于两点：1.接口方式足够方便，不要我调一堆数据要写一长段代码，并且速度够快。2.数据组织内容足够清晰准确。虽然看上去就两句话，但是能做好太难了，比如拿最标准的行情数据来看，也没有一个能做好的。数据这个活需要很深的积累沉淀，并不是现在互联网商业模式下大家追求的东西，所以。。。</p><p>第二块是交易接口<br>通用的方便的交易接口，CTP方面已经作出了很好的表率。<br>交易接口其实很简单，挂单、撤单、查询核心做好三个功能就ok了，<br>不过由于政策的原因，这块可能有一定的困难。</p><p>为什么说这两块东西？很简单，首先是必需品，数据和交易都是永远绕不开的，<br>这个是做量化的基础工作，所以你能帮助大家在这块减少时间就是一个有用的东西。<br>其次是安全性，知道我提取了哪些数据和下单情况并不能有效破解我的策略，反正现在数据供应商和经纪公司也是知道这个的。</p><p>另外回测系统可以做，但是不是这种写代码回测，也不是这种日线级别的回测。<br>是要做一个类似模拟交易所一样扔挂单撤单的tick级的回测系统，<br>可惜这个太难有能力做这个的人肯定自己做对冲基金不会拿出来做成一个商业化的平台，看不上这些小钱。</p><p>最后大家在搞什么在线编程平台、社交之类的东西。<br>我的看法就是要么你脑子不清楚不知道用户要什么，要么就是挂羊头卖狗肉，<br>真正想做的东西并不是量化平台，赚钱的点当然也就不是提供一个量化平台那么简单的事情了。</p><h1 id="用户的想法"><a href="#用户的想法" class="headerlink" title="用户的想法"></a>用户的想法</h1><p>我们是做这个行业的，公司里一般要求策略不可以拿到云端去跑，保密性不高，<br>但偶尔有时间去看看大家都有啥有意思的想法，就目前观察结果来看，以科普和灌水居多，<br>很多帖子以普及量化知识为主，有价值的策略并不多。<br>真实的量化交易以清洗数据、梳理数据为主，<br>写代码做回测在实际工作中占比不大，贡献估计在20～30%左右，<br>而另一方面我们平时写的代码复杂度远超过几根均线或者简单排序，<br>有些时候Function需要自己定义，还需要很多自定义的过程，<br>然而这些并不是最烦的，最烦的是需要分析原数据、检查缺失值和异常值，<br>做大量的描述性统计分析，之后需要对数据结果进行反复的交叉对比和检查，<br>以防出现未来函数或者数据错误，这类问题有时候是代码的问题，有时候是数据本身的问题，<br>在云端跑最大的问题就是数据的质量无法确保。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;量化交易平台要解决的问题&quot;&gt;&lt;a href=&quot;#量化交易平台要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;量化交易平台要解决的问题&quot;&gt;&lt;/a&gt;量化交易平台要解决的问题&lt;/h1&gt;&lt;p&gt;量化交易最终要实现一个可以运行的策略。大体上可以研究阶段和运
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/order_and_match.html"/>
    <id>http://holbrook.github.io/2017/10/26/order_and_match.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p> abc</p><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>::uml:: format=”png” alt=”Sample sequence diagram”<br>  participant User</p><p>  User -&gt; A: DoWork<br>  activate A #FFBBBB</p><p>  A -&gt; A: Internal call<br>  activate A #DarkSalmon</p><p>  A -&gt; B: &lt;&lt; createRequest &gt;&gt;<br>  activate B</p><p>  B –&gt; A: RequestCreated<br>  deactivate B<br>  deactivate A<br>  A -&gt; User: Done<br>  deactivate A<br>::end-uml::</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; abc&lt;/p&gt;
&lt;h1 id=&quot;demo&quot;&gt;&lt;a href=&quot;#demo&quot; class=&quot;headerlink&quot; title=&quot;demo&quot;&gt;&lt;/a&gt;demo&lt;/h1&gt;&lt;p&gt;::uml:: format=”png” alt=”Sample sequence diagram”
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/p_quant_and_q_quant.html"/>
    <id>http://holbrook.github.io/2017/10/26/p_quant_and_q_quant.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Q-度量和-P-度量"><a href="#Q-度量和-P-度量" class="headerlink" title="Q 度量和 P 度量"></a>Q 度量和 P 度量</h1><p>Q是指风险中性测度。风险中性的意思主要是说历史数据不能帮助你预测未来的走势，所以你的决策是没有风险补偿的。这当然是一个非常虚幻的假设，但是由此而得的模型可以给出漂亮的数学性质，而且可以在缺乏数据的情况下得到一些结论，所以有一定的实际意义。涉及的数学技术主要是随机过程，偏微分方程之类。在数学派系里，这些显得相对高端，一般人概念里都是那些脑袋不太正常的人类捣鼓的玩意。</p><p>P是指真实概率测度。所谓真实，主要是说模型依赖的概率分布是从历史数据上估算出来的。严格来讲我个人不认为这种东西叫做“真实”，最多只能说是从真实数据上估算出来的，显然没有什么东西保证历史一定会重演（比如黑天鹅）。但是这个是目前大家公认的说法，所以咱们不较真。从定义可以看出这套方法主要依赖数据，数据量越大估算的效果越好。涉及的技术主要是时间序列（ARIMA，GARCH之类），Bayesian，以及现在流行的机器学习等方法。不难看出，为了倒腾数据，这套方法练到上层就要开始刷装备。在电子化时代这最终演化为拼机房的军备竞赛。</p><p>两者对比可以看出，Q重模型而轻数据，P则重数据而轻模型。当然两者也都要即有模型也有数据，但从应用上来讲，Q者是模型固定，用数据来精化模型的参数（calibration）；而P者则可以有若干备选模型，由数据的计算结果来选择最佳的模型（estimation）。</p><p>q quant来自于q measure，也就是风险中性测度。<br>资产定价理论中最基本的原理，就是风险中性测度对应着无套利，无套利对应着可以完美对冲各种风险。<br>所以q quant主要是协助structuring desk和exotic trading desk来做衍生品定价。<br>银行卖那些复杂的衍生品是为了赚手续费（1%左右），并不是与客户对赌。</p><p>在q quant的协助下，银行把衍生品卖出去，对冲掉所有风险，收客户一笔手续费，这才是sell-side最本职的工作。</p><p>而p quant来自于physical prob measure，也就是“预测未来走势”，常见于买方和卖方的自营交易部。<br>所谓预测未来走势，无非就是寻找under-priced risks/over-priced risks（不好意思不会翻译），<br>也就是所谓的“找alpha”，因此p quant也叫alpha quant。</p><p>所以，<br>q quant做的是“如何不承担风险”。<br>p quant做的是“承担哪些风险”。</p><p>这两类quant的界限其实可以很不明显。举个例子，volatility trading做的就是对冲掉股票价格风险（q measure），预测未来波动率走势（p measure）。</p><p>不过很有可能很多人是看不明白背后的逻辑的，比如说 为什么叫Q 为什么叫P<br>（其实就是两个二叉树的 概率，此处有人把上面那只写为q 下面的概率就是1-q了 当然也有人相反，我学这个的时候的老师 就是下面的是定义为q）</p><p>我本科生学计算数学的 我以一个数学的稍微形象一些的比喻来形容下<br>Stochastic Calculus 就好比是 求解析解<br>而Statistical Learning 就好比是求 数值解</p><p>你问为什么既要求解析解又要求数值解的<br>因为 现在的金融体系的基础假设有一些时候是不一定成立的，比如最出名最经典的B-S model<br>假设波动率是固定的，事实的情况是 黑色星期一以后 波动率不固定了<br>出现隐含波动率了 原有的假设的根基就不存在了 怎么办？</p><p>求隐含波动率 用隐含波动率算局部波动率 然后再用局部波动率进行回推吧（这地方是derman的研究领域）具体的得参见他的东西，我就是随便那么一说 不严谨的。derman就是写宽客人生那位。</p><p>至于到底是因为什么 波动率微笑了 那就又得扯到行为金融学角度的东西了 跟本篇内容不大。</p><p>重点是 如何来衡量这种波动率微笑 这就得Statistical Learning这方面来做了。</p><p>也就是我说的类似于求数值解，并不一定需要精确的知道这个的原理是什么 而是需要知道我们通过什么样的方式能够求得近似的可用的解（可以理解为对asset定价），同时知道这种计算得到的解的精度是多少，在什么条件下可用。这就足够了。</p><p>同样我个人也同样第一的回答，认为未来是Statistical Learning 的这个方向。<br>这个上面说的很明白了，其实这种认识跟我很早之前怀疑过数学的往计算数学发展方向不对，后期又认为计算数学才是现今数学的发展主流一样。（最后这个仅个人观点）</p><p>二叉树的那个例子实际上是指两个不同的概率测度：真实概率测度和风险中性测度。你可能会有疑问，在风险中性测度下的定价在真实世界是否适用？正统的回答是两个测度是等价的，所以在一种概率测度下几乎必然有效的对冲，在另一种测度下也几乎必然有效。更学术的推导和论证推荐参考Shreve的《金融随机分析》。</p><h1 id="量化投资模型的分类"><a href="#量化投资模型的分类" class="headerlink" title="量化投资模型的分类"></a>量化投资模型的分类</h1><p>量化投资模型可分为两大类，Q测度和P测度。</p><p>Q测度代表了衍生品定价，它的任务是预测当下趋势。</p><p>P测度代表了量化风险和投资组合管理，它的任务是构建未来模型。</p><p>　　总的来说，Q测度多用于汇率衍生品的量化投资，又称风险中性测度。<br>注重使用包括随机过程和偏微方程在内的数学模型制定低价机制。<br>对数据的要求不要，甚至可以使用随机数字，因为在Q测度中历史数据不参与测定金融市场的未来走势。<br>Q测度的核心课题在于基础量化投资模型得出了投资组合如何才能不承担风险。</p><p>　　而P测度多用于股票量化投资，又称真是概率测度。<br>注重数据的选取，一数据统计为基石分析金融市场的未来走向，<br>P测度中量化投资模型的数据量与预测精度成正相关，换句话说P测度就是大数据(Big Data)。<br>P测度的核心课题在于量化投资模型得出了投资组合讲承担哪些风险。</p><p>　　虽然P测度和Q测度模型所得出了量化投资结果有很大不同，但在不同领域中这两种测度也有相同点，比如风险溢价计算，随机过程，数值计算法，套期保值，套利统计等方面。</p><h2 id="Q-测度"><a href="#Q-测度" class="headerlink" title="Q 测度"></a>Q 测度</h2><p>　　衍生品定价的目标是流动性证券基于供需定价的规则之下，为一个给定的证券制定合适的价格，<br>这类证券包括奇异期权，抵押贷款支持证券，可转换证券和结构性产品等。<br>一旦价格被确定，卖方就能在市场上对该证券组织买卖。<br>所以，衍生品定价通常是卖方为了保持证券在货币市场上的价值所采取的一系列推断。Q测度最大的难点在于校准。</p><h2 id="P-测度"><a href="#P-测度" class="headerlink" title="P 测度"></a>P 测度</h2><p>　　P测度代表了量化投资模型对风险和资产投资组合的演算。<br>风险和投资组合的目标在于在一个给定的未来投资模板中计算市场价格的概率分布。<br>市场的这种真实概率测度就由P测度来表示。而Q表示风险中性测度。</p><p>投资者根据P测度决定购买何种证券以提高投资组合的收益并且降低风险。</p><p>　　P测度的数据展现了历史价格的动态模型以及其他的金融变量，这些数据在离散的时间节点采集并根据时间先后排列。<br>P测度在量化投资领域最大的挑战是预估。对不同时间段的分析需要先进的多元统计和计量经济学算法。<br>在P测度框架下，预估证券的联合分布至关重要，所以与Q测度不同，P测度不主张分析单个证券。</p><p>因此以线性因子模型为代表的降维技术在P测度中尤为重要。近年来，在量化投资领域中，P测度很受青睐，<br>有不少原本投向Q测度的资源都转投了P测度。</p><h2 id="二者关系"><a href="#二者关系" class="headerlink" title="二者关系"></a>二者关系</h2><p>好吧，我相信你已经晕了——为什么在真实概率空间外，还会有一个Q概率空间，这不是一下子可以说清楚的问题，我就给一个简单的例子，剩下的如果你还有兴趣可以再自己研究：</p><p>假设现在只有两种资产，一种是股票，一种是债券，假设一年后这个世界只有两种情景，一种是好市场，一种是坏市场，各自出现的概率是60%和40%。我们画一个表格，就有：<br>t=0 | t=1 Good (60%) | t=1 Bad (40%)<br>Stock 1 | 1.2 | 0.8<br>Bond 1 | 1.1 | 1.1</p><p>表格里面的数字代表价格，比如第一行表示股票今天1元，一年后在好的情况下变成1.2元，而坏的情况下变成0.8元；第二行因为债券是固定收益，两种请都是10%的收益。</p><p>那么在P概率空间（真实概率空间），股票的Expected Return就是：</p><p>也就是4%，那么这不符合金融数学均衡思想，因为其期望收益和无风险回报不相等（10%）。所有Q measure下面的两种情况的概率应该是75%和25%，这样股票的回报就成了：</p><p>这样满足了理论微观经济学的各种假设，你就可以基于此概率去定价一个期权了，或者其它更加复杂的衍生产品。</p><p>这套体系由Arrow在1965年建立，之后他也成为了诺奖得主。而基于这一体系诞生了Black Scholes（1973）期权定价公式，在很长一段时间内被业界奉为圭臬。</p><p>但是这一体系太理论化了，在实际做交易的时候会缺少指导意义。就好比Wolf of Wall Street里面，Can you sell the pen now，那支笔有理论价值，比如市场同类的价格是多少，成本是多少，不能偏差太多，不然就有套利，但是你的交易价格可能远远偏离这个价格，因为这一单取决于购买者的现实需求，而这或许可以从历史交易数据中得出，这就是统计学习方法可以应用的场景。</p><p>在业界呆了一段时间后，我开始重新思考这个问题——为什么1960到2000年大量的金融研究在随机微积分领域开展，而2000年后，大量的金融研究开始应用越来越复杂的计量经济学和机器学习方法。我个人的看法是——早期数据的缺失，使得数学建模——随机微积分成为唯一可行的方法，而2000年后数据的蓬勃发展，使得统计学习成为可能。要知道Fama在1970写有效市场理论市场的数据是Dow Jones里面30支股票的10年日交易数据，这是当时的大数据，而现在，所有股票的每单级别的数据也不罕见了，数据——信息驱动研究的变化，在每个领域都是一样。这不难解释为什么机器学习逐渐主流了——30年前没有数据，何来金融统计分析？</p><p>这两种方法（Q世界与P世界）在一定假设下可以得到相同的结果，比如你设定同样的无套利、经济人理性等条件，随机微积分与统计学习可以得到非常接近的期权定价。但是统计学习的好处是，你知道这个世界的不完美，你可以随意放松无套利和理性交易这些太过严格的假设，依然获得鲁棒性不错的模型。</p><p>那么在今天的Quant世界，这两者的应用是怎样的呢？做风险和定价的Quant，还是采用传统的随机微积分为纲领，这种方法算出来的价格被交易员用来作为交易和对冲的指导，但是交易员的报价还是根据自己的判断来进行；在山的另一边，做程序化做市（Automatic Market Making）、资产配置或者高频交易的Quant，无一例外的活动在P世界——基于大数据和先进的机器学习来发现交易机会。</p><p>是信息行业的发展重塑了整个金融研究，但这不意外——要知道数百年前就是提前获得的关于英法战争结果信息帮助了罗斯柴尔德家族成为欧洲金融霸主——信息一直就是金融中最关键的edge。</p><p>从Quant自身来说，我觉得P世界——统计学习方向是未来，随着数据越来越多，实证方法很有可能长期成为主流——甚至随机微积分的传统强势领域也可能为之侵蚀。但是随机微积分领域的很多理论与方法是古典经济学的集大成之作，如果你想获得更好的直觉，这些是必须深入研究的，不然你很可能沦为反复在同一数据上使用不同的统计包碰运气的data miner。</p><h1 id="模型角度"><a href="#模型角度" class="headerlink" title="模型角度"></a>模型角度</h1><p>从Quantitative Modeling的角度来说，有两大主流的方向：Stochastic Calculus（随机微积分）和Statistical Learning（统计学习）。这两个主流方向基本涵盖了你所有可能用到的技术——随机微积分，或者说金融数学，提供了各种衍生产品的风险估计基础，也是处理新型资产定价的常用方式；而统计学习，则包罗计量经济学、时间序列分析和各种机器学习方法。我个人比较喜欢用Q measure世界和P measure世界来指代这两种方法，因为统计学习主要在真实概率空间进行分析，而随机微积分在基于无套利假定而设立的Q概率空间进行分析。</p><h1 id="算法角度"><a href="#算法角度" class="headerlink" title="算法角度"></a>算法角度</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[^1]: <a href="https://www.zhihu.com/question/24820388" target="_blank" rel="external">P Quant 和 Q Quant 到底哪个是未来？</a><br>[^2]: <a href="http://www.idwzx.com/post/p-quantq-quant" target="_blank" rel="external">P Quant和Q Quant,量化投资的逼格担当</a><br>[^3]: <a href="http://quant.dataguru.cn/article-5826-1.html" target="_blank" rel="external">Q Quant VS. P Quant：量化投资江湖的剑宗与气宗之争</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Q-度量和-P-度量&quot;&gt;&lt;a href=&quot;#Q-度量和-P-度量&quot; class=&quot;headerlink&quot; title=&quot;Q 度量和 P 度量&quot;&gt;&lt;/a&gt;Q 度量和 P 度量&lt;/h1&gt;&lt;p&gt;Q是指风险中性测度。风险中性的意思主要是说历史数据不能帮助你预测未来的走势，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/quantitative_investment11.html"/>
    <id>http://holbrook.github.io/2017/10/26/quantitative_investment11.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>第11章 时间序列方法</p><p>11.1 时间序列的基本概念<br>11.1.1 时间序列的定义<br>11.1.2 时间序列的组成因素<br>11.1.3 时间序列的分类<br>11.1.4 时间序列分析方法<br>11.2 平稳时间序列分析方法<br>11.2.1 移动平均法<br>11.2.2 指数平滑法<br>11.3 季节指数预测法<br>11.3.1 季节性水平模型<br>11.3.2 季节性趋势模型<br>11.4 时间序列模型<br>11.4.1 ARMA模型<br>11.4.2 ARIMA模型<br>11.4.3 ARCH模型<br>11.4.4 GARCH模型<br>11.5 应用实例：基于时间序列的股票预测<br>11.6 本章小结<br>参考文献</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第11章 时间序列方法&lt;/p&gt;
&lt;p&gt;11.1 时间序列的基本概念&lt;br&gt;11.1.1 时间序列的定义&lt;br&gt;11.1.2 时间序列的组成因素&lt;br&gt;11.1.3 时间序列的分类&lt;br&gt;11.1.4 时间序列分析方法&lt;br&gt;11.2 平稳时间序列分析方法&lt;br&gt;11.2.1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/quantitative_investment10.html"/>
    <id>http://holbrook.github.io/2017/10/26/quantitative_investment10.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>第10章 诊断方法</p><p>10.1 离群点诊断概要<br>10.1.1 离群点诊断的定义<br>10.1.2 离群点诊断的作用<br>10.1.3 离群点诊断方法分类<br>10.2 基于统计的离群点诊断<br>10.2.1 理论基础<br>10.2.2 应用实例<br>10.2.3 优点与缺点<br>10.3 基于距离的离群点诊断<br>10.3.1 理论基础<br>10.3.2 应用实例<br>10.3.3 优点与缺点<br>10.4 基于密度的离群点挖掘<br>10.4.1 理论基础<br>10.4.2 应用实例<br>10.4.3 优点与缺点<br>10.5 基于聚类的离群点挖掘<br>10.5.1 理论基础<br>10.5.2 应用实例<br>10.5.3 优点与缺点<br>10.6 应用实例：离群点诊断量化择时<br>10.7 延伸阅读：新兴的离群点挖掘方法<br>10.7.1 基于关联的离群点挖掘<br>10.7.2 基于粗糙集的离群点挖掘<br>10.7.3 基于人工神经网络的离群点挖掘<br>10.8 本章小结<br>参考文献</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第10章 诊断方法&lt;/p&gt;
&lt;p&gt;10.1 离群点诊断概要&lt;br&gt;10.1.1 离群点诊断的定义&lt;br&gt;10.1.2 离群点诊断的作用&lt;br&gt;10.1.3 离群点诊断方法分类&lt;br&gt;10.2 基于统计的离群点诊断&lt;br&gt;10.2.1 理论基础&lt;br&gt;10.2.2 应用实例&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/quant_resources.html"/>
    <id>http://holbrook.github.io/2017/10/26/quant_resources.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><p>joinquant</p><h1 id="joinquant"><a href="#joinquant" class="headerlink" title="joinquant"></a>joinquant</h1><ul><li><a href="https://www.joinquant.com/study" target="_blank" rel="external">python编程</a><ul><li>【进阶】时间操作</li><li>【进阶】函数式编程和列表生成式</li><li>【科学计算】Numpy库</li><li>【科学计算】pandas库之数据查看、选择</li><li>【科学计算】pandas库之数据处理与规整</li><li>【类库】Statsmodels 统计包之 OLS 回归</li><li>【类库】scikit-learn 之 kNN 分类</li><li>多回测运行和参数分析框架<br>+</li></ul></li></ul><h1 id="大奖章"><a href="#大奖章" class="headerlink" title="大奖章"></a><a href="http://www.dajiangzhang.com/" target="_blank" rel="external">大奖章</a></h1><h1 id="riceQuant"><a href="#riceQuant" class="headerlink" title="riceQuant"></a>riceQuant</h1><h1 id="…"><a href="#…" class="headerlink" title="…"></a>…</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;—&quot;&gt;&lt;a href=&quot;#—&quot; class=&quot;headerlink&quot; title=&quot;—&quot;&gt;&lt;/a&gt;—&lt;/h2&gt;&lt;p&gt;joinquant&lt;/p&gt;
&lt;h1 id=&quot;joinquant&quot;&gt;&lt;a href=&quot;#joinquant&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/quantitative_investment12.html"/>
    <id>http://holbrook.github.io/2017/10/26/quantitative_investment12.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>第12章 智能优化方法</p><p>12.1 智能优化方法概要<br>12.1.1 智能优化方法的概念<br>12.1.2 在量化投资中的作用<br>12.1.3 常用的智能优化方法<br>12.2 遗传算法<br>12.2.1 遗传算法的原理<br>12.2.2 遗传算法的步骤<br>12.2.3 遗传算法实例<br>12.2.4 遗传算法的特点<br>12.3 模拟退火算法<br>12.3.1 模拟退火算法的原理<br>12.3.2 模拟退火算法步骤<br>12.3.3 模拟退火算法实例<br>12.3.4 模拟退火算法的特点<br>12.4 应用实例：组合投资优化<br>12.4.1 问题描述<br>12.4.2 求解过程<br>12.5 延伸阅读：其他智能方法<br>12.5.1 粒子群算法<br>12.5.2 蚁群算法<br>12.6 本章小结<br>参考文献</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第12章 智能优化方法&lt;/p&gt;
&lt;p&gt;12.1 智能优化方法概要&lt;br&gt;12.1.1 智能优化方法的概念&lt;br&gt;12.1.2 在量化投资中的作用&lt;br&gt;12.1.3 常用的智能优化方法&lt;br&gt;12.2 遗传算法&lt;br&gt;12.2.1 遗传算法的原理&lt;br&gt;12.2.2 遗传算
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/quantitative_investment16.html"/>
    <id>http://holbrook.github.io/2017/10/26/quantitative_investment16.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>第16章 基于数据挖掘技术的量化交易系统</p><p>16.1 交易系统概述<br>16.1.1 交易系统的定义<br>16.1.2 交易系统的作用<br>16.2 DM交易系统总体设计<br>16.2.1 系统目标<br>16.2.2 相关约定<br>16.2.3 系统结构<br>16.3 短期交易子系统<br>16.3.1 子系统功能描述<br>16.3.2 数据预处理模块<br>16.3.3 量化选股模块<br>16.3.4 策略回测模块<br>16.4 中长期交易子系统<br>16.4.1 子系统功能描述<br>16.4.2 导入数据模块<br>16.4.3 投资组合优化模块<br>16.5 系统的拓展与展望<br>16.6 本章小结<br>参考文献</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第16章 基于数据挖掘技术的量化交易系统&lt;/p&gt;
&lt;p&gt;16.1 交易系统概述&lt;br&gt;16.1.1 交易系统的定义&lt;br&gt;16.1.2 交易系统的作用&lt;br&gt;16.2 DM交易系统总体设计&lt;br&gt;16.2.1 系统目标&lt;br&gt;16.2.2 相关约定&lt;br&gt;16.2.3 系统
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/quantitative_investment15.html"/>
    <id>http://holbrook.github.io/2017/10/26/quantitative_investment15.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>第15章 数据挖掘在股票程序化交易中的综合应用</p><p>15.1 程序化交易概述<br>15.1.1 程序化交易的定义<br>15.1.2 程序化交易的实现过程<br>15.1.3 程序化交易的分类<br>15.2 数据的处理及探索<br>15.2.1 获取股票日交易数据<br>15.2.2 计算指标<br>15.2.3 数据标准化<br>15.2.4 变量筛选<br>15.3 模型的建立及评估<br>15.3.1 股票预测的基本思想<br>15.3.2 模型的训练及评价<br>15.4 组合投资的优化<br>15.4.1 组合投资的理论基础<br>15.4.2 组合投资的实现<br>15.5 程序化交易的实施<br>15.6 本章小结<br>参考文献</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第15章 数据挖掘在股票程序化交易中的综合应用&lt;/p&gt;
&lt;p&gt;15.1 程序化交易概述&lt;br&gt;15.1.1 程序化交易的定义&lt;br&gt;15.1.2 程序化交易的实现过程&lt;br&gt;15.1.3 程序化交易的分类&lt;br&gt;15.2 数据的处理及探索&lt;br&gt;15.2.1 获取股票日交易
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/quantitative_investment14.html"/>
    <id>http://holbrook.github.io/2017/10/26/quantitative_investment14.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>第14章 配对交易策略的挖掘与实现</p><p>14.1 配对交易概述<br>14.1.1 配对交易的定义<br>14.1.2 配对交易的特点<br>14.1.3 配对选取步骤<br>14.2 协整检验的理论基础<br>14.2.1 协整关系的定义<br>14.2.2 EG两步协整检验法<br>14.2.3 Johansen协整检验法<br>14.3 配对交易的实现<br>14.3.1 协整检验的实现<br>14.3.2 配对交易函数<br>14.3.3 协整配对中的参数优化<br>14.4 延伸阅读：配对交易的三要素<br>14.4.1 配对交易的前提<br>14.4.2 配对交易的关键<br>14.4.3 配对交易的假设<br>14.5 本章小结<br>参考文献</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第14章 配对交易策略的挖掘与实现&lt;/p&gt;
&lt;p&gt;14.1 配对交易概述&lt;br&gt;14.1.1 配对交易的定义&lt;br&gt;14.1.2 配对交易的特点&lt;br&gt;14.1.3 配对选取步骤&lt;br&gt;14.2 协整检验的理论基础&lt;br&gt;14.2.1 协整关系的定义&lt;br&gt;14.2.2 E
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/svm_model.html"/>
    <id>http://holbrook.github.io/2017/10/26/svm_model.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/quantitative_investment9.html"/>
    <id>http://holbrook.github.io/2017/10/26/quantitative_investment9.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>第9章 预测方法</p><p>9.1 预测方法概要<br>9.1.1 预测的概念<br>9.1.2 预测的基本原理<br>9.1.3 量化投资中预测的主要内容<br>9.1.4 预测的准确度评价及影响因素<br>9.1.5 常用的预测方法<br>9.2 灰色预测<br>9.2.1 灰色预测原理<br>9.2.2 灰色预测的实例<br>9.3 马尔科夫预测<br>9.3.1 马尔科夫预测的原理<br>9.3.2 马尔科夫过程的特性<br>9.3.3 马尔科夫预测的实例<br>9.4 应用实例：大盘走势预测<br>9.4.1 数据的选取及模型的建立<br>9.4.2 预测过程<br>9.4.3 预测结果与分析<br>9.5 本章小结<br>参考文献</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第9章 预测方法&lt;/p&gt;
&lt;p&gt;9.1 预测方法概要&lt;br&gt;9.1.1 预测的概念&lt;br&gt;9.1.2 预测的基本原理&lt;br&gt;9.1.3 量化投资中预测的主要内容&lt;br&gt;9.1.4 预测的准确度评价及影响因素&lt;br&gt;9.1.5 常用的预测方法&lt;br&gt;9.2 灰色预测&lt;br&gt;9
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/quantitative_investment8.html"/>
    <id>http://holbrook.github.io/2017/10/26/quantitative_investment8.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>第8章 聚类方法</p><p><a href="{filename}quantitative_investment_index.md">《量化投资：数据挖掘技术与实践(MatLab版)》读书笔记目录</a></p><p>8.1 聚类方法概要<br>8.1.1 聚类的概念<br>8.1.2 类的度量方法<br>8.1.3 聚类方法的应用场景<br>8.1.4 聚类方法的分类<br>8.2 K-means方法<br>8.2.1 K-means的原理和步骤<br>8.2.2 K-means实例1：自主编程<br>8.2.3 K-means实例2：集成函数<br>8.2.4 K-means的特点<br>8.3 层次聚类<br>8.3.1 层次聚类的原理和步骤<br>8.3.2 层次聚类的实例<br>8.3.3 层次聚类的特点<br>8.4 神经网络聚类<br>8.4.1 神经网络聚类的原理和步骤<br>8.4.2 神经网络聚类的实例<br>8.4.3 神经网络聚类的特点<br>8.5 模糊C-均值（FCM）方法<br>8.5.1 FCM的原理和步骤<br>8.5.2 FCM的应用实例<br>8.5.3 FCM算法的特点<br>8.6 高斯混合聚类方法<br>8.6.1 高斯混合聚类的原理和步骤<br>8.6.2 高斯聚类的实例<br>8.6.3 高斯聚类的特点<br>8.7 类别数的确定方法<br>8.7.1 类别的原理<br>8.7.2 类别的实例<br>8.8 应用实例：股票聚类分池<br>8.8.1 聚类目标和数据描述<br>8.8.2 实现过程<br>8.8.3 结果及分析<br>8.9 延伸阅读<br>8.9.1 目前聚类分析研究的主要内容<br>8.9.2 SOM智能聚类算法<br>8.10 本章小结<br>参考文献</p><p><a href="{filename}quantitative_investment_index.md">《量化投资：数据挖掘技术与实践(MatLab版)》读书笔记目录</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第8章 聚类方法&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;{filename}quantitative_investment_index.md&quot;&gt;《量化投资：数据挖掘技术与实践(MatLab版)》读书笔记目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8.1 聚类方法概要&lt;br&gt;8.1.1 聚类的概念
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://holbrook.github.io/2017/10/26/multifactor_model.html"/>
    <id>http://holbrook.github.io/2017/10/26/multifactor_model.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《利用Python进行数据分析》小结</title>
    <link href="http://holbrook.github.io/2017/10/26/dataology/python-for-data-analysis/index.html"/>
    <id>http://holbrook.github.io/2017/10/26/dataology/python-for-data-analysis/index.html</id>
    <published>2017-10-26T10:54:39.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>《<a href="https://book.douban.com/subject/25779298/" target="_blank" rel="external">利用Python进行数据分析</a>》读书笔记的总结。</p><a id="more"></a><p>《利用Python进行数据分析(Python for　Data Analysis)》，这本书的作者 Wes McKinney 就是 pandas 的作者。</p><p>从书中的内容可以分析出来，作者应该是用 Matlab 和 R 比较不爽，又觉得 NumPy 的功能比较有限，<br>所以开发了 pandas (Python Data Analysis Library)。</p><p>顾名思义，pandas 提供了用python进行数据分析的工具集。作者认为，<a href="/2017/02/14/python_data_analysis2.html">数据分析的一般步骤包括</a>：</p><ul><li>数据加载：从各种格式的数据文件和数据库加载数据</li><li>数据准备: 对数据进行清理、修整、整合、规范化、重塑、切片切块、变形等处理，以便于进行分析</li><li>数据转换：对数据集进行数学和统计运算，产生新的数据集。比如，根据分组变量对一个大表进行聚合</li><li>建模和计算：通过统计模型、机器学习算法和其他计算工具，对数据进行分析计算</li><li>结果展示：通过静态或交互式的方式，展示结果</li></ul><p>熟悉数据仓库的朋友可能发现，其中前三个步骤类似于传统的ETL(Extract-Transform-Load， 抽取-转换-加载)，后两个步骤类似于数据挖掘和BI。</p><p>数据分析的一般步骤<br>数据加载<br>从各种格式的数据文件和数据库加载数据</p><p>数据准备<br>对数据进行清理、修整、整合、规范化、重塑、切片切块、变形等处理，以便于进行分析</p><p>数据转换<br>对数据集进行数学和统计运算，产生新的数据集。比如，根据分组变量对一个大表进行聚合</p><p>建模和计算<br>通过统计模型、机器学习算法和其他计算工具，对数据进行分析计算</p><p>结果展示<br>通过静态或交互式的方式，展示结果</p><p>从 Pandas本身来说，<br>NumPy定义了数组ndarray, 而Pandas定义了Series, DataFrame和 Panel。其中：</p><p>Series = Index + ndarray ，带索引的数组<br>DataFrame = Index + N * Series, 一组具有相同索引的Series<br>Panel = ?</p><p>围绕DataFrame，pandas的主要知识点包括：</p><h1 id="构建DataFrame"><a href="#构建DataFrame" class="headerlink" title="构建DataFrame"></a>构建DataFrame</h1><ol><li>将数据加载到 DataFrame</li></ol><h1 id="操作索引"><a href="#操作索引" class="headerlink" title="操作索引"></a>操作索引</h1><h1 id="操作列"><a href="#操作列" class="headerlink" title="操作列"></a>操作列</h1><h1 id="操作行"><a href="#操作行" class="headerlink" title="操作行"></a>操作行</h1><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><h1 id="操作数据"><a href="#操作数据" class="headerlink" title="操作数据"></a>操作数据</h1><ol><li><p>通过 pandas 提供的方法对数据进行处理</p></li><li><p>通过 pandas 提供的方法对数据进行转换</p></li></ol><h2 id="对DataFrame中的数据建模和计算"><a href="#对DataFrame中的数据建模和计算" class="headerlink" title="对DataFrame中的数据建模和计算"></a>对DataFrame中的数据建模和计算</h2><pre><code>pandas, 一些简单的方法satms.scik -learntransflow?</code></pre><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>pandas中简单的展示<br>   更复杂的：</p><p>NumPy(Numerical Python) 提供了大量的数值编程工具，<br><a href="/2017/02/17/python_data_analysis4.html">可以方便地处理向量、线性代数、矩阵等运算，并支持一些数学和统计方法</a>。<br>NumPy 也是 pandas 的重要基础。</p><p>此外，作者还介绍了<a href="#">NumPy的高级应用</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《&lt;a href=&quot;https://book.douban.com/subject/25779298/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;利用Python进行数据分析&lt;/a&gt;》读书笔记的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://holbrook.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="python" scheme="http://holbrook.github.io/tags/python/"/>
    
      <category term="读书笔记" scheme="http://holbrook.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>云计算简介</title>
    <link href="http://holbrook.github.io/2017/10/24/cloud_computing.html"/>
    <id>http://holbrook.github.io/2017/10/24/cloud_computing.html</id>
    <published>2017-10-24T13:26:23.000Z</published>
    <updated>2017-10-28T07:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念篇"><a href="#概念篇" class="headerlink" title="概念篇"></a>概念篇</h1><h2 id="云计算是什么"><a href="#云计算是什么" class="headerlink" title="云计算是什么"></a>云计算是什么</h2><p>出于 <del>不同理解</del> 商业目的，云计算的定义不下20种，解释不下100种。</p><p>我的理解：</p><ul><li><p>云(Cloud)<br>在IT领域，云通常指资源的集合。其特点是规模庞大，细节不重要，可动态伸缩。</p></li><li><p>计算(Computing)<br>这里应该指计算能力。计算能力取决于可用于计算的资源，包括软件运行需要的各种平台软件、操作系统、CPU能力、内存大小、存储空间、网络带宽等。</p></li><li><p>云计算(Cloud Computing)<br>通过分布在 <strong>大量</strong> 计算机上的资源构成资源池，为 <strong>大量</strong> 应用系统提供所需的<br>计算力、存储空间、网络带宽和其他服务。应用系统不需要知道支持其运行的各种资源的底层细节情况。</p></li></ul><h2 id="云计算的特征"><a href="#云计算的特征" class="headerlink" title="云计算的特征"></a>云计算的特征</h2><p>基于上述定义，可以得出云计算在 <strong>提供资源方面</strong> 的特征：</p><ul><li><p>多对多<br>用大量的计算机，为大量的应用提供所需的资源。</p></li><li><p>可动态伸缩<br>云的规模可以根据需要随时扩大或减小，而不影响上面运行的应用系统。</p></li><li><p>成本更低<br>通过动态的分配和调度，提高资源使用效率，使得单个应用系统运行所需的成本更低。</p></li><li><p>灵活使用<br>应用系统可以根据需要，随时获取、按需使用资源，而且可以做到按使用计费。<br>现在有的云计算平台甚至可以做到按分钟、按每M流量计费。</p></li></ul><h2 id="常见-误区-误导"><a href="#常见-误区-误导" class="headerlink" title="常见 误区 误导"></a>常见 <del>误区</del> 误导</h2><ul><li><p>云计算不一定依赖互联网<br>不依赖互联网的不一定不是云，比如私有云。<br>依赖互联网的不一定是云，很可能是伪云。</p></li><li><p>云计算是服务于开发/运维人员<br>对于应用系统的用户来说，其实并不关心其是否运行在“云”上。</p></li></ul><h2 id="什么不是云计算"><a href="#什么不是云计算" class="headerlink" title="什么不是云计算"></a>什么不是云计算</h2><ul><li><p>云应用：基于云计算的应用<br>如前所述，用户只关心应用的功能和性能，不关心应用如何实现，如何部署。<br>通常，大部分应用不在云平台上也能运行。</p></li><li><p>伪云： 把简单的互联网应用套在云计算上</p><ul><li>搜狗云输入法 –&gt; 网络输入法（词库放在服务器上）</li><li>有道云笔记 –&gt; 网络笔记（笔记内容放在服务器上）</li><li>网易云音乐 –&gt; 网络音乐（音频文件放在服务器上）</li><li>百度云网盘 –&gt; 网盘（各种文件放在服务器上）</li></ul></li></ul><h1 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h1><h2 id="分层体系架构"><a href="#分层体系架构" class="headerlink" title="分层体系架构"></a>分层体系架构</h2><p>分层体系架构( Layered Architecture),是IT领域的重要思想。</p><p>分层体系架构将系统的组件分隔到不同的层中，每一层中的组件保持内聚性，并且大致在同一抽象级别( <strong>高内聚</strong> )；每一层都通过接口访问下一层，不关心其具体实现。下层不会调用上层( <strong>低耦合</strong> )。这样把问题划分开来各个解决，易于控制，易于延展，易于分配资源( <strong>分而治之</strong> )。</p><p>分层架构可以带来很多好处：</p><ul><li>每层专业分工</li><li>层间接口固定，替换某一层不影响其它层</li><li>有利于通用组件的复用</li><li>利于系统的水平扩展</li></ul><p>本文相关的分层架构包括：</p><ul><li>开发角度的分层架构</li></ul><div style="margin: 0.5em 0px; display: block!important; text-align: center"><?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Generated by graphviz version 2.40.1 (20161225.0304) --><!-- Title: G Pages: 1 --><svg width="74pt" height="83pt" viewbox="0.00 0.00 74.16 83.40" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 79.4)"><title>G</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-79.4 70.1592,-79.4 70.1592,4 -4,4"/><!-- DEV_layers --><g id="node1" class="node"><title>DEV_layers</title><polygon fill="none" stroke="#000000" points="0,-.5 0,-74.9 66.1592,-74.9 66.1592,-.5 0,-.5"/><text text-anchor="middle" x="33.0796" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">展现层</text><polyline fill="none" stroke="#000000" points="0,-50.1 66.1592,-50.1 "/><text text-anchor="middle" x="33.0796" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">逻辑层</text><polyline fill="none" stroke="#000000" points="0,-25.3 66.1592,-25.3 "/><text text-anchor="middle" x="33.0796" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">存储层</text></g></g></svg></div><ul><li>运维角度的分层架构</li></ul><div style="margin: 0.5em 0px; display: block!important; text-align: center"><?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Generated by graphviz version 2.40.1 (20161225.0304) --><!-- Title: G Pages: 1 --><svg width="98pt" height="108pt" viewbox="0.00 0.00 98.39 108.20" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 104.2)"><title>G</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-104.2 94.3904,-104.2 94.3904,4 -4,4"/><!-- OPS_layers --><g id="node1" class="node"><title>OPS_layers</title><polygon fill="none" stroke="#000000" points="0,-.5 0,-99.7 90.3904,-99.7 90.3904,-.5 0,-.5"/><text text-anchor="middle" x="45.1952" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">应用软件</text><polyline fill="none" stroke="#000000" points="0,-74.9 90.3904,-74.9 "/><text text-anchor="middle" x="45.1952" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">平台软件</text><polyline fill="none" stroke="#000000" points="0,-50.1 90.3904,-50.1 "/><text text-anchor="middle" x="45.1952" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统</text><polyline fill="none" stroke="#000000" points="0,-25.3 90.3904,-25.3 "/><text text-anchor="middle" x="45.1952" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">硬件</text></g></g></svg></div><h2 id="硬件不足与集群"><a href="#硬件不足与集群" class="headerlink" title="硬件不足与集群"></a>硬件不足与集群</h2><p>之前很长一段时间，计算机硬件的能力不足以满足软件的运行。<br>主要的解决手段是集群和负载均衡技术。与升级硬件相比，这种扩充能力的方式成为“水平扩展”。</p><ul><li><p>集群(Cluster)<br>将多个计算机连接到一起，像一台机器那样工作。这样可以增加处理能力，或者提高稳定性。</p></li><li><p>负载均衡(Load Balancing)<br>按照一定的规则，将负载分配到集群中的各个计算机上进行处理。</p></li></ul><p>集群和负载均衡技术，可以应用在不同的层级上面。其上的各层，都运行在集群环境。</p><ul><li>操作系统集群</li></ul><div style="margin: 0.5em 0px; display: block!important; text-align: center"><?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Generated by graphviz version 2.40.1 (20161225.0304) --><!-- Title: G Pages: 1 --><svg width="385pt" height="133pt" viewbox="0.00 0.00 385.24 133.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 129)"><title>G</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-129 381.238,-129 381.238,4 -4,4"/><!-- node1 --><g id="node1" class="node"><title>node1</title><polygon fill="none" stroke="#000000" points="0,-.5 0,-124.5 152.619,-124.5 152.619,-.5 0,-.5"/><text text-anchor="middle" x="76.3095" y="-107.9" font-family="Times,serif" font-size="14.00" fill="#000000">应用软件</text><polyline fill="none" stroke="#000000" points="0,-99.7 152.619,-99.7 "/><text text-anchor="middle" x="76.3095" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">平台软件</text><polyline fill="none" stroke="#000000" points="0,-74.9 152.619,-74.9 "/><text text-anchor="middle" x="76.3095" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统集群软件</text><polyline fill="none" stroke="#000000" points="0,-50.1 152.619,-50.1 "/><text text-anchor="middle" x="76.3095" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统</text><polyline fill="none" stroke="#000000" points="0,-25.3 152.619,-25.3 "/><text text-anchor="middle" x="76.3095" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">硬件</text></g><!-- node2 --><g id="node2" class="node"><title>node2</title><polygon fill="none" stroke="#000000" points="224.619,-.5 224.619,-124.5 377.238,-124.5 377.238,-.5 224.619,-.5"/><text text-anchor="middle" x="300.9285" y="-107.9" font-family="Times,serif" font-size="14.00" fill="#000000">应用软件</text><polyline fill="none" stroke="#000000" points="224.619,-99.7 377.238,-99.7 "/><text text-anchor="middle" x="300.9285" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">平台软件</text><polyline fill="none" stroke="#000000" points="224.619,-74.9 377.238,-74.9 "/><text text-anchor="middle" x="300.9285" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统集群软件</text><polyline fill="none" stroke="#000000" points="224.619,-50.1 377.238,-50.1 "/><text text-anchor="middle" x="300.9285" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统</text><polyline fill="none" stroke="#000000" points="224.619,-25.3 377.238,-25.3 "/><text text-anchor="middle" x="300.9285" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">硬件</text></g><!-- node1&#45;&#45;node2 --><g id="edge1" class="edge"><title>node1:lb&#45;&#45;node2:lb</title><path fill="none" stroke="#000000" stroke-width="10" d="M152.3095,-62.5C152.3095,-62.5 224.9285,-62.5 224.9285,-62.5"/></g></g></svg></div><ul><li>应用服务器集群</li></ul><div style="margin: 0.5em 0px; display: block!important; text-align: center"><?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Generated by graphviz version 2.40.1 (20161225.0304) --><!-- Title: G Pages: 1 --><svg width="386pt" height="133pt" viewbox="0.00 0.00 385.99 133.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 129)"><title>G</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-129 381.9884,-129 381.9884,4 -4,4"/><!-- node1 --><g id="node1" class="node"><title>node1</title><polygon fill="none" stroke="#000000" points="0,-.5 0,-124.5 152.9942,-124.5 152.9942,-.5 0,-.5"/><text text-anchor="middle" x="76.4971" y="-107.9" font-family="Times,serif" font-size="14.00" fill="#000000">应用软件</text><polyline fill="none" stroke="#000000" points="0,-99.7 152.9942,-99.7 "/><text text-anchor="middle" x="76.4971" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">应用服务器集群软件</text><polyline fill="none" stroke="#000000" points="0,-74.9 152.9942,-74.9 "/><text text-anchor="middle" x="76.4971" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">Websphere</text><polyline fill="none" stroke="#000000" points="0,-50.1 152.9942,-50.1 "/><text text-anchor="middle" x="76.4971" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统</text><polyline fill="none" stroke="#000000" points="0,-25.3 152.9942,-25.3 "/><text text-anchor="middle" x="76.4971" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">硬件</text></g><!-- node2 --><g id="node2" class="node"><title>node2</title><polygon fill="none" stroke="#000000" points="224.9942,-.5 224.9942,-124.5 377.9884,-124.5 377.9884,-.5 224.9942,-.5"/><text text-anchor="middle" x="301.4913" y="-107.9" font-family="Times,serif" font-size="14.00" fill="#000000">应用软件</text><polyline fill="none" stroke="#000000" points="224.9942,-99.7 377.9884,-99.7 "/><text text-anchor="middle" x="301.4913" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">应用服务器集群软件</text><polyline fill="none" stroke="#000000" points="224.9942,-74.9 377.9884,-74.9 "/><text text-anchor="middle" x="301.4913" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">Websphere</text><polyline fill="none" stroke="#000000" points="224.9942,-50.1 377.9884,-50.1 "/><text text-anchor="middle" x="301.4913" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统</text><polyline fill="none" stroke="#000000" points="224.9942,-25.3 377.9884,-25.3 "/><text text-anchor="middle" x="301.4913" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">硬件</text></g><!-- node1&#45;&#45;node2 --><g id="edge1" class="edge"><title>node1:lb&#45;&#45;node2:lb</title><path fill="none" stroke="#000000" stroke-width="10" d="M152.4971,-87.5C152.4971,-87.5 225.4913,-87.5 225.4913,-87.5"/></g></g></svg></div><ul><li>数据库集群</li></ul><div style="margin: 0.5em 0px; display: block!important; text-align: center"><?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Generated by graphviz version 2.40.1 (20161225.0304) --><!-- Title: G Pages: 1 --><svg width="336pt" height="133pt" viewbox="0.00 0.00 336.23 133.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 129)"><title>G</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-129 332.2324,-129 332.2324,4 -4,4"/><!-- node1 --><g id="node1" class="node"><title>node1</title><polygon fill="none" stroke="#000000" points="0,-.5 0,-124.5 128.1162,-124.5 128.1162,-.5 0,-.5"/><text text-anchor="middle" x="64.0581" y="-107.9" font-family="Times,serif" font-size="14.00" fill="#000000">数据库实例</text><polyline fill="none" stroke="#000000" points="0,-99.7 128.1162,-99.7 "/><text text-anchor="middle" x="64.0581" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">数据库集群软件</text><polyline fill="none" stroke="#000000" points="0,-74.9 128.1162,-74.9 "/><text text-anchor="middle" x="64.0581" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">Oracle</text><polyline fill="none" stroke="#000000" points="0,-50.1 128.1162,-50.1 "/><text text-anchor="middle" x="64.0581" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统</text><polyline fill="none" stroke="#000000" points="0,-25.3 128.1162,-25.3 "/><text text-anchor="middle" x="64.0581" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">硬件</text></g><!-- node2 --><g id="node2" class="node"><title>node2</title><polygon fill="none" stroke="#000000" points="200.1162,-.5 200.1162,-124.5 328.2324,-124.5 328.2324,-.5 200.1162,-.5"/><text text-anchor="middle" x="264.1743" y="-107.9" font-family="Times,serif" font-size="14.00" fill="#000000">数据库实例</text><polyline fill="none" stroke="#000000" points="200.1162,-99.7 328.2324,-99.7 "/><text text-anchor="middle" x="264.1743" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">数据库集群软件</text><polyline fill="none" stroke="#000000" points="200.1162,-74.9 328.2324,-74.9 "/><text text-anchor="middle" x="264.1743" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">Oracle</text><polyline fill="none" stroke="#000000" points="200.1162,-50.1 328.2324,-50.1 "/><text text-anchor="middle" x="264.1743" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统</text><polyline fill="none" stroke="#000000" points="200.1162,-25.3 328.2324,-25.3 "/><text text-anchor="middle" x="264.1743" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">硬件</text></g><!-- node1&#45;&#45;node2 --><g id="edge1" class="edge"><title>node1:lb&#45;&#45;node2:lb</title><path fill="none" stroke="#000000" stroke-width="10" d="M128.0581,-87.5C128.0581,-87.5 200.1743,-87.5 200.1743,-87.5"/></g></g></svg></div><h2 id="硬件过剩与云计算"><a href="#硬件过剩与云计算" class="headerlink" title="硬件过剩与云计算"></a>硬件过剩与云计算</h2><p>随着硬件技术的飞速发展，现在计算机的性能远远高于软件的需要。也就是说，硬件资源过剩了。为了提高使用效率，产生了一些新的技术。</p><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>  一台计算机只运行一个操作系统，资源可能闲置。通过虚拟化，可以在一台计算机上运行多个操作系统，这些操作系统共享硬件资源。<br>  这里面的关键是资源调度程序，或者叫“虚拟化操作系统”。</p><div style="margin: 0.5em 0px; display: block!important; text-align: center"><?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Generated by graphviz version 2.40.1 (20161225.0304) --><!-- Title: G Pages: 1 --><svg width="266pt" height="108pt" viewbox="0.00 0.00 266.00 108.20" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 104.2)"><title>G</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-104.2 262,-104.2 262,4 -4,4"/><!-- vm --><g id="node1" class="node"><title>vm</title><polygon fill="none" stroke="#000000" points="0,-.5 0,-99.7 258,-99.7 258,-.5 0,-.5"/><text text-anchor="middle" x="43" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="0,-74.9 86,-74.9 "/><text text-anchor="middle" x="43" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统1</text><polyline fill="none" stroke="#000000" points="86,-50.1 86,-99.7 "/><text text-anchor="middle" x="129" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="86,-74.9 172,-74.9 "/><text text-anchor="middle" x="129" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统2</text><polyline fill="none" stroke="#000000" points="172,-50.1 172,-99.7 "/><text text-anchor="middle" x="215" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="172,-74.9 258,-74.9 "/><text text-anchor="middle" x="215" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统3</text><polyline fill="none" stroke="#000000" points="0,-50.1 258,-50.1 "/><text text-anchor="middle" x="129" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">资源调度程序</text><polyline fill="none" stroke="#000000" points="0,-25.3 258,-25.3 "/><text text-anchor="middle" x="129" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">硬件</text></g></g></svg></div><p>可能有人运行过单机的“虚拟机软件”，比如vmware。虚拟机和虚拟化的本质不同在于：资源调度程序运行在不同的层上。</p><div style="margin: 0.5em 0px; display: block!important; text-align: center"><?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Generated by graphviz version 2.40.1 (20161225.0304) --><!-- Title: G Pages: 1 --><svg width="266pt" height="133pt" viewbox="0.00 0.00 266.00 133.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 129)"><title>G</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-129 262,-129 262,4 -4,4"/><!-- vm --><g id="node1" class="node"><title>vm</title><polygon fill="none" stroke="#000000" points="0,-.5 0,-124.5 258,-124.5 258,-.5 0,-.5"/><text text-anchor="middle" x="43" y="-107.9" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="0,-99.7 86,-99.7 "/><text text-anchor="middle" x="43" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统1</text><polyline fill="none" stroke="#000000" points="86,-74.9 86,-124.5 "/><text text-anchor="middle" x="129" y="-107.9" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="86,-99.7 172,-99.7 "/><text text-anchor="middle" x="129" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统2</text><polyline fill="none" stroke="#000000" points="172,-74.9 172,-124.5 "/><text text-anchor="middle" x="215" y="-107.9" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="172,-99.7 258,-99.7 "/><text text-anchor="middle" x="215" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统3</text><polyline fill="none" stroke="#000000" points="0,-74.9 258,-74.9 "/><text text-anchor="middle" x="129" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">虚拟机软件</text><polyline fill="none" stroke="#000000" points="0,-50.1 258,-50.1 "/><text text-anchor="middle" x="129" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统</text><polyline fill="none" stroke="#000000" points="0,-25.3 258,-25.3 "/><text text-anchor="middle" x="129" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">硬件</text></g></g></svg></div><h3 id="虚拟化-集群"><a href="#虚拟化-集群" class="headerlink" title="虚拟化+集群"></a>虚拟化+集群</h3><p>单个的计算机上面能够运行的虚拟机个数还是有限的。要想进一步增加容量，很容易想到可以把前面提到的集群技术用到虚拟化的资源调度程序上：</p><div style="margin: 0.5em 0px; display: block!important; text-align: center"><?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Generated by graphviz version 2.40.1 (20161225.0304) --><!-- Title: G Pages: 1 --><svg width="668pt" height="108pt" viewbox="0.00 0.00 668.00 108.20" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 104.2)"><title>G</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-104.2 664,-104.2 664,4 -4,4"/><!-- node1 --><g id="node1" class="node"><title>node1</title><polygon fill="none" stroke="#000000" points="0,-.5 0,-99.7 172,-99.7 172,-.5 0,-.5"/><text text-anchor="middle" x="43" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="0,-74.9 86,-74.9 "/><text text-anchor="middle" x="43" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统1</text><polyline fill="none" stroke="#000000" points="86,-50.1 86,-99.7 "/><text text-anchor="middle" x="129" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="86,-74.9 172,-74.9 "/><text text-anchor="middle" x="129" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统2</text><polyline fill="none" stroke="#000000" points="0,-50.1 172,-50.1 "/><text text-anchor="middle" x="86" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">资源调度程序</text><polyline fill="none" stroke="#000000" points="0,-25.3 172,-25.3 "/><text text-anchor="middle" x="86" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">硬件</text></g><!-- node2 --><g id="node2" class="node"><title>node2</title><polygon fill="none" stroke="#000000" points="244,-.5 244,-99.7 416,-99.7 416,-.5 244,-.5"/><text text-anchor="middle" x="287" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="244,-74.9 330,-74.9 "/><text text-anchor="middle" x="287" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统3</text><polyline fill="none" stroke="#000000" points="330,-50.1 330,-99.7 "/><text text-anchor="middle" x="373" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="330,-74.9 416,-74.9 "/><text text-anchor="middle" x="373" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统4</text><polyline fill="none" stroke="#000000" points="244,-50.1 416,-50.1 "/><text text-anchor="middle" x="330" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">资源调度程序</text><polyline fill="none" stroke="#000000" points="244,-25.3 416,-25.3 "/><text text-anchor="middle" x="330" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">硬件</text></g><!-- node1&#45;&#45;node2 --><g id="edge1" class="edge"><title>node1:lb&#45;&#45;node2:lb</title><path fill="none" stroke="#000000" stroke-width="10" d="M172,-38.1C172,-38.1 244,-38.1 244,-38.1"/></g><!-- node3 --><g id="node3" class="node"><title>node3</title><polygon fill="none" stroke="#000000" points="488,-.5 488,-99.7 660,-99.7 660,-.5 488,-.5"/><text text-anchor="middle" x="531" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="488,-74.9 574,-74.9 "/><text text-anchor="middle" x="531" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统5</text><polyline fill="none" stroke="#000000" points="574,-50.1 574,-99.7 "/><text text-anchor="middle" x="617" y="-83.1" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="574,-74.9 660,-74.9 "/><text text-anchor="middle" x="617" y="-58.3" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统6</text><polyline fill="none" stroke="#000000" points="488,-50.1 660,-50.1 "/><text text-anchor="middle" x="574" y="-33.5" font-family="Times,serif" font-size="14.00" fill="#000000">资源调度程序</text><polyline fill="none" stroke="#000000" points="488,-25.3 660,-25.3 "/><text text-anchor="middle" x="574" y="-8.7" font-family="Times,serif" font-size="14.00" fill="#000000">硬件</text></g><!-- node2&#45;&#45;node3 --><g id="edge2" class="edge"><title>node2:lb&#45;&#45;node3:lb</title><path fill="none" stroke="#000000" stroke-width="10" d="M416,-38.1C416,-38.1 488,-38.1 488,-38.1"/></g></g></svg></div><p>这样就构建了一个大的资源池。</p><h3 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a>云存储</h3><p>上面的架构中，虚拟机还不能无缝从一个主机迁移到另一个主机运行。关键问题在于：虚拟机是存储在硬盘上的，一个主机无法访问另一个主机的硬盘。<br>最简单的办法当然是所有的虚拟机都存储在一个存储设备(比如EMC存储)上，所有的主机都能访问这个存储设备。但这显然是多对一的关系，而且不可动态伸缩。<br>我们需要一种符合云计算特征的存储功能，不妨称作云存储(Cloud Storage)。</p><p>如果把“文件存储”看做一种特殊的应用，这个问题可以很容易的用前面的模式解决：</p><div style="margin: 0.5em 0px; display: block!important; text-align: center"><?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Generated by graphviz version 2.40.1 (20161225.0304) --><!-- Title: G Pages: 1 --><svg width="420pt" height="214pt" viewbox="0.00 0.00 420.00 214.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 210)"><title>G</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-210 416,-210 416,4 -4,4"/><g id="clust1" class="cluster"><title>cluster_2</title><polygon fill="none" stroke="#000000" points="53.6782,-8 53.6782,-74 358.3218,-74 358.3218,-8 53.6782,-8"/></g><g id="clust2" class="cluster"><title>cluster_1</title><polygon fill="none" stroke="#000000" points="8,-82 8,-198 404,-198 404,-82 8,-82"/></g><!-- store1 --><g id="node1" class="node"><title>store1</title><polygon fill="none" stroke="#000000" points="61.6782,-16.2 61.6782,-65.8 142.3218,-65.8 142.3218,-16.2 61.6782,-16.2"/><text text-anchor="middle" x="102" y="-49.2" font-family="Times,serif" font-size="14.00" fill="#000000">SAN程序</text><polyline fill="none" stroke="#000000" points="61.6782,-41 142.3218,-41 "/><text text-anchor="middle" x="102" y="-24.4" font-family="Times,serif" font-size="14.00" fill="#000000">硬件(存储)</text></g><!-- store2 --><g id="node2" class="node"><title>store2</title><polygon fill="none" stroke="#000000" points="269.6782,-16.2 269.6782,-65.8 350.3218,-65.8 350.3218,-16.2 269.6782,-16.2"/><text text-anchor="middle" x="310" y="-49.2" font-family="Times,serif" font-size="14.00" fill="#000000">SAN程序</text><polyline fill="none" stroke="#000000" points="269.6782,-41 350.3218,-41 "/><text text-anchor="middle" x="310" y="-24.4" font-family="Times,serif" font-size="14.00" fill="#000000">硬件(存储)</text></g><!-- store1&#45;&#45;store2 --><g id="edge1" class="edge"><title>store1:lb&#45;&#45;store2:lb</title><path fill="none" stroke="#000000" stroke-width="10" d="M142,-53C198.8889,-53 213.1111,-53 270,-53"/></g><!-- node1 --><g id="node3" class="node"><title>node1</title><polygon fill="none" stroke="#000000" points="16,-90.4 16,-189.6 188,-189.6 188,-90.4 16,-90.4"/><text text-anchor="middle" x="59" y="-173" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="16,-164.8 102,-164.8 "/><text text-anchor="middle" x="59" y="-148.2" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统1</text><polyline fill="none" stroke="#000000" points="102,-140 102,-189.6 "/><text text-anchor="middle" x="145" y="-173" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="102,-164.8 188,-164.8 "/><text text-anchor="middle" x="145" y="-148.2" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统2</text><polyline fill="none" stroke="#000000" points="16,-140 188,-140 "/><text text-anchor="middle" x="102" y="-123.4" font-family="Times,serif" font-size="14.00" fill="#000000">资源调度程序</text><polyline fill="none" stroke="#000000" points="16,-115.2 188,-115.2 "/><text text-anchor="middle" x="102" y="-98.6" font-family="Times,serif" font-size="14.00" fill="#000000">硬件(CPU、内存、网络)</text></g><!-- node2 --><g id="node4" class="node"><title>node2</title><polygon fill="none" stroke="#000000" points="224,-90.4 224,-189.6 396,-189.6 396,-90.4 224,-90.4"/><text text-anchor="middle" x="267" y="-173" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="224,-164.8 310,-164.8 "/><text text-anchor="middle" x="267" y="-148.2" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统3</text><polyline fill="none" stroke="#000000" points="310,-140 310,-189.6 "/><text text-anchor="middle" x="353" y="-173" font-family="Times,serif" font-size="14.00" fill="#000000">...</text><polyline fill="none" stroke="#000000" points="310,-164.8 396,-164.8 "/><text text-anchor="middle" x="353" y="-148.2" font-family="Times,serif" font-size="14.00" fill="#000000">操作系统4</text><polyline fill="none" stroke="#000000" points="224,-140 396,-140 "/><text text-anchor="middle" x="310" y="-123.4" font-family="Times,serif" font-size="14.00" fill="#000000">资源调度程序</text><polyline fill="none" stroke="#000000" points="224,-115.2 396,-115.2 "/><text text-anchor="middle" x="310" y="-98.6" font-family="Times,serif" font-size="14.00" fill="#000000">硬件(CPU、内存、网络)</text></g><!-- node1&#45;&#45;node2 --><g id="edge2" class="edge"><title>node1:lb&#45;&#45;node2:lb</title><path fill="none" stroke="#000000" stroke-width="10" d="M188,-128C204,-128 208,-128 224,-128"/></g></g></svg></div><p>其中SAN(Storage Area Network，存储区域网络)，是一种服务器连接外部存储设备的架构技术。从操作系统的角度，访问外部的存储设备与访问本机的硬盘没有任何区别。<br>该技术可以采用光纤等设备，使得访问外部存储的速度达到甚至超过本机硬盘。</p><h3 id="管理和调度"><a href="#管理和调度" class="headerlink" title="管理和调度"></a>管理和调度</h3><p>现在，已经有了足够的灵活性：可以创建虚拟机，可以为虚拟机分配和调整资源，可以指定虚拟机运行在哪一个主机上。但是还可以更加智能一些。</p><ul><li><p>自动分配<br>创建新虚拟机时，根据需要的资源和各主机的情况，自动分配主机</p></li><li><p>自动平衡<br>监控各个主机的运行状况，当主机资源紧张时自动将虚拟机迁移到空闲的主机上运行，在此过程中对虚拟机访问不受任何影响。</p></li><li><p>自助服务<br>用户可以自助创建虚拟机，决定使用多少资源。并按照实际使用情况实时计费。</p></li><li><p>区域自治<br>对于某些用户，可以为其分配一个大的资源池（比如，5000GHz CPU、3TB 内存、3PB 存储空间、1TB网络带宽），这个资源池的管理员可以创建子用户，子用户使用池中的资源再创建自己的虚拟机。</p></li><li><p>更多功能<br>没有做不到，只有想不到！</p></li></ul><h2 id="XaaS"><a href="#XaaS" class="headerlink" title="XaaS"></a>XaaS</h2><p>尽管业内搞死了SOA，但是服务(Service)这个词已经到处在使用，什么东西都可以是服务。<br>在云计算领域，根据提供资源的层次不同，可以分为 IaaS, PaaS, SaaS。</p><ul><li>IaaS (基础设施即服务)</li></ul><p>前面的例子中，都是把CPU、内存、存储空间、网络带宽以及管理这些硬件的操作系统作为资源。<br>这些资源提供出去，就叫做基础设施即服务（IaaS, Infrastructure-as-a- Service）。</p><ul><li>PaaS（平台即服务）</li></ul><p>PaaS把平台(Platform)作为资源。什么是平台，还要从分层架构说起。<br>开发一个应用系统，总有很多共同的功能，比如http服务，session管理，数据库连接池等等。如果每一个应用系统的开发都重新实现这些功能，效率太低。于是有一些组织，将这些公共的功能提取出来，发布成一个软件，就叫做平台软件。<br>平台软件也叫做容器，可以支持很多应用系统的运行。平台软件在架构的层次中，介于应用系统和操作系统之间。</p><div style="margin: 0.5em 0px; display: block!important; text-align: center"><?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><!-- Generated by graphviz version 2.40.1 (20161225.0304) --><!-- Title: G Pages: 1 --><svg width="8pt" height="8pt" viewbox="0.00 0.00 8.00 8.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 4)"><title>G</title><polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-4 4,-4 4,4 -4,4"/></g></svg></div><ul><li>SaaS(软件即服务)</li></ul><p>平台软件是通用的，业务无关的。但对于某些特定类型的应用，有一些共同的功能和逻辑。比如CDN、视频直播等、用户认证等。<br>把这些功能提取出来，作为一种资源在多个应用系统中复用，就可以称之为 SaaS。<br>这些服务的对象，仍然是开发人员。对于最终用户来说，这些服务并不能直接使用。</p><h1 id="行业篇"><a href="#行业篇" class="headerlink" title="行业篇"></a>行业篇</h1><h2 id="云计算简史"><a href="#云计算简史" class="headerlink" title="云计算简史"></a>云计算简史</h2><p>云计算从概念，到技术研究，到现在的广泛使用，大概经历了以下几个阶段：</p><ul><li><p>概念的建立</p><ul><li>1983年，Sun 提出 The Network is the  Computer</li><li>2006年3月，Amazon 推出弹性计算云（Elastic Compute Cloud；EC2）服务</li><li>2006年8月，Google 首次提出“云计算”（Cloud Computing）的概念</li></ul></li><li><p>试验田</p><ul><li>2007年10月，Google 和 IBM 开始在美国大学校园推广云计算的计划<br>目标：降低分布式计算技术在学术研究方面的成本<br>通过数百台服务器提供服务，学生可以通过网络开展以大规模计算为基础的研究</li><li>2008年1月，Google 宣布在台湾启动“云计算学术计划”</li></ul></li></ul><ul><li><p>吃螃蟹<br>这个阶段，主要提供面向个人开发者和小企业的PaaS服务。</p><ul><li>2007年6月, Heroku 对外提供服务</li><li>2008年4月，google发布GAE(Google App Engine)</li><li>2009年8月，新浪开始开发SAE(Sina App Engine),11月正式推出第一个Alpha版本</li></ul></li></ul><ul><li>抢市场<ul><li>2008年2月，IBM 宣布在无锡科教产业园为中国的软件公司建立全球第一个云计算中心</li><li>2008年7月，雅虎、惠普和英特尔宣布推出云计算联合研究计划，在全球建立6个云计算的数据中心</li><li>2008年8月，戴尔申请“云计算”（Cloud Computing）商标</li><li>2009年8月，李彦宏提出”框计算”</li></ul></li></ul><ul><li><p>抢占制高点</p><ul><li>2010年3月，Novell与云安全联盟（CSA）共同宣布一项 ~供应商中立计划~ ，名为“可信任云计算计划（Trusted Cloud Initiative）”。</li><li>2010年7月，美国国家航空航天局和包括Rackspace、AMD、Intel、Dell等支持厂商共同宣布“OpenStack”开放源代码计划，</li><li>2010年10月, 微软表示支持OpenStack与Windows Server 2008 R2的集成</li><li>2011年2月，思科系统正式加入OpenStack，重点研制OpenStack的网络服务</li></ul></li><li><p>商业化服务<br>目前比较适合商业化的，还是面向企业级客户的IaaS服务。</p><ul><li>2011年7月，阿里云上线，开始大规模对外提供云计算服务(2009年创立公司)</li><li>2013年7月，青云上线</li></ul></li></ul><h2 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h2><p>　六、云的诱惑</p><p>　　试想，有了云上的“机房”，你如果是中小企业的IT部经理或CIO，你还会在建设机房上操心供电、空调、消防、设备故障等等琐事吗?你还会去调研购买何种服务器设备吗?你只需要一个帐号、一个信用卡，你就可以在云上“机房”里随意创建任何服务器，喜欢就启动，不喜欢就删除。你可以安装所需要的操作系统、配置任何数据库。你甚至不需要为员工购置PC电脑，有“云桌面”就可以了。</p><p>　　英国政府用不到一年的时间，迅速建起了统一的“政府云”(简称“G云”)，目的是把国家各个政府部门的IT系统都逐步转移到G云上去。自2012年正式启用之日起，政府各个部门一律禁止购买硬件的服务器，所有新增内容都必须是从G云上创建。</p><p>　　不管是企业、政府、还是个人，如果想避开云，看来是很困难了。这就是为什么要多少了解一下“到底什么是云”。</p><p>云计算是一种按使用量付费的模式，<br>这种模式提供可用的、便捷的、按需的网络访问，<br>进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。</p><p>用户不再需要了解“云”中基础设施的细节，不必具有相应的专业知识，也无需直接进行控制。云计算描述了一种基于互联网的新的IT服务增加、使用和交付模式，</p><p>计算能力也可作为一种商品通过互联网进行流通。</p><p>它旨在通过网络把多个成本相对较低的计算实体整合成一个具有强大计算能力的完美系统</p><h2 id="参与者类型"><a href="#参与者类型" class="headerlink" title="参与者类型"></a>参与者类型</h2><p>云计算在技术上已经比较成熟了，在整个产业链中，有多类参与者：</p><ul><li><p>云技术<br>搭建私有云/公有云所需要的产品和技术。</p><p>一个重要的趋势是，软件开源、免费。厂商支持开源软件的开发，通过这种方式推广自己的“标准”。<br>厂商通过解释自己的标准(以解决方案、技术支持的形式)赚钱，不再赚实施的辛苦钱。</p><p>如果硬件厂商针对云计算推出了新的硬件设备，也可以归为此类。</p></li><li><p>云服务<br>这里主要指提供公有云服务，供使用者租用。竞争的方式主要是通过规模效应拼成本。当然也要看个性化的服务功能。<br>目前主要是提供IaaS、PaaS服务，SaaS服务正在慢慢积累。</p></li><li><p>云周边<br>为了提高云平台的运行效率，需要很多工具。这些支持云平台运行的产品和技术，是云计算技术的周边产业。<br>比如针对云平台的监控、测试、安全等。</p></li><li><p>云应用<br>与“伪云”不同，有些应用必须在云计算的环境下运行，比如基于大数据的应用。<br>这些应用能够带来与传统应用不同的新的价值。</p></li></ul><h3 id="云技术"><a href="#云技术" class="headerlink" title="云技术"></a>云技术</h3><p>商业产品：<br>  VMware<br>  微软</p><p>开源产品<br>  Openfiler<br>  OpenStack<br>  Xen<br>  KVM</p><h3 id="云周边"><a href="#云周边" class="headerlink" title="云周边"></a>云周边</h3><p>Citrix公司在监控程序上采用的是开源的Xen</p><h3 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h3><p>按照服务的对象和范围，云可以分为三类：</p><p>　　私有云：建一个云，如果只是为了单位(企业或机构)自己使用，就是私有云。就前面提到的“机房”而言，每个“机房”只是为本单位的不同部门、或不同用途而设立的。</p><p>　　公众云：如果云的服务对象是社会上的客户，就是公众云。前面提到的“机房”可以是任何社会上的企业、单位、或个人。Amazon公司的AWS是现在世界上最大的公众云。其它公众云提供商还有Google、Salesforce、苹果的iCloud等等。</p><p>　　混合云：如果一个云，既是为单位自己使用，也对外开放资源服务，就是混合云。有时，把两个或多个私有云的联合，也叫混合云。</p><p>　　6. 私有云(Private cloud)<br>私有云是为一个客户单独使用而构建的，因而提供对数据、安全性和服务质量的最有效控制。该公司拥有基础设施，并可以控制在此基础设施上部署应用程序的方式。私有云可部署在企业数据中心的防火墙内，也可以将它们部署在一个安全的主机托管场所。</p><p>　　私有云可由公司自己的 IT 机构，也可由云提供商进行构建。在此“托管式专用”模式中，像 Sun ，IBM这样的云计算提供商可以安装、配置和运营基础设施，以支持一个公司企业数据中心内的专用云。此模式赋予公司对于云资源使用情况的极高水平的控制能力，同时带来建立并运作该环境所需的专门知识。</p><p>　　7. 公共云(Public cloud)</p><p>　　公共云又称外部云，是指通过因特网动态地、灵活地以自助方式获取资源。</p><p>　　8. 混合云(Hybrid cloud)</p><p>　　混合云环境包含了多种内部云和/或外部云，“将会适用于大多数企业”，因为，通过集成多种云服务用户可以减少向公有云迁移时所面临的问题，如PCI compliance等。</p><p>　　9. 社区云(Community cloud)</p><p>　　社区云是指一些由有着类似需求并打算共享基础设施的组织共同创立的云，社区云的目的是实现云计算的一些优势。由于共同费用的用户数比公有云少，这种选择往往比公有云贵，但隐私度安、全性和政策遵从都比公有云高。</p><p>　　10. 云际云(The Intercloud)</p><p>　　云际云的概念最早是在2007年由Kevin Kelly提出的，他认为最终会有一个云的云，就是云际云。云际云的概念是“因特网的因特网”这一概念的扩展，2009年，云际云的概念开始流行起来，也用于描述未来的数据中心。</p><p>　　云际云的概念是建立在单个云不能包括无线资源的观点之上的，试想如果一个云包括了所有的虚拟基础设施资源，包括计算和存储资源，它将不能满足将的客户发送的服务进一步进行分配的需求。云际云就是用于解决这类问题的，事实上，每一个云都可以使用其他云上的虚拟基础设施，包括计算和存储资源。这种“为使用付费”的形式为云供应商带来了新的商机。当然，云际云也存在着诸多挑战，如云的联合、安全性、互操作性、QoS、监管和计费等。</p><h3 id="云应用"><a href="#云应用" class="headerlink" title="云应用"></a>云应用</h3><ul><li>云计算与大数据</li></ul><p>从技术上看,大数据与云计算的关系就像一枚硬币的正反面一样密不可分。<br>大数据必然无法用单台的计算机进行处理,必须采用分布式计算架构。<br>它的特色在于对海量数据的挖掘,但它必须依托云计算的分布式处理、分布式数据库、云存储和虚拟化技术。[1]</p><p>云计算是继1980年代大型计算机到客户端-服务器的大转变之后的又一种巨变。<br>云计算（Cloud Computing）是分布式计算（Distributed Computing）、并行计算（Parallel Computing）、效用计算（Utility Computing）、  网络存储（Network Storage Technologies）、虚拟化（Virtualization）、负载均衡（Load Balance）、热备份冗余（High Available）等传统计算机和网络技术发展融合的产物。<br>网格计算(Grid Computing)</p><p>云计算是虚拟化(Virtualization)、公用计算(Utility Computing)、IaaS(基础设施即服务)、PaaS(平台即服务)、SaaS(软件即服务)等概念混合演进并跃升的结果。</p><p>云计算（Cloud Computing）是网格计算（Grid Computing）、分布式计算（Distributed Computing）、<br>并行计算（Parallel Computing）、效用计算（Utility Computing）、<br>网络存储（Network Storage Technologies）、虚拟化（Virtualization）、<br>负载均衡（Load Balance）<br>等传统计算机技术和网络技术发展融合的产物。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>传统的SaaS早就有</p><ul><li>DNS</li><li>CDN</li></ul><h3 id="私有云案例"><a href="#私有云案例" class="headerlink" title="私有云案例"></a>私有云案例</h3><p>　　43. 中国移动 大“云”(Big Cloud)</p><p>　　中国移动研究院从2007年开始进行云计算的研究和开发，是最早介入云计算研发和实践的企业之一。中国移动在2007年初利用闲置的15台PC服务器，基于开源软件搭建了海量数据处理试验平台，并成功运行搜索引擎软件。2008年底，中国移动进一步建设了 256台PC服务器、1000个CPU Core、256TB存储组成的“大云”试验平台，结合现网数据挖掘、用户行为分析等需求进行了应用试点，在提高效率、降低成本、节能减排等方面取得了显著的效果。（点击查看IT168云计算频道：中国移动”大云”1.0系统功能与产品解读）</p><p>　　经过3年多的努力，2009年，中国移动研究院正式对外公布了正在研发和试验的平台“BigCloud——大云”，平台规模进一步扩容，达到1000台服务器、5000个CPU Core、3000TB的存储规模，并以此提升中国移动未来在移动互联网方面的信息服务能力，2009年9月，在中国移动研究院内部发布了大云(Big Cloud 0.5)版本，供内部试用。</p><p>　　最新的1.0版本计划在2010年5月21日发布，可实现分布式文件系统、分布式海量数据仓库、分布式计算框架、集群管理、云存储系统、弹性计算系统、并行数据挖掘工具等关键功能</p><p>　　</p><h3 id="宏源"><a href="#宏源" class="headerlink" title="宏源"></a>宏源</h3><p>我们公司最早的实验环境是我搭建的，用4台 HP380 提供服务，用 4台HP380作为存储，<br>为开发测试环境提供30多个“云主机”服务。</p><p>带来的好处:<br>提高了测试系统的部署速度，<br>可以随时调配测试环境需要的资源。<br>节约了机房空间和电力消耗。</p><p>这个案例的成功，促成了后来生产环境的虚拟化项目。</p><h2 id="提供内容"><a href="#提供内容" class="headerlink" title="提供内容"></a>提供内容</h2><h2 id="问题-商业机会"><a href="#问题-商业机会" class="headerlink" title="问题(商业机会)"></a>问题(商业机会)</h2><p>云计算服务除了提供计算服务外，还必然提供了存储服务。但是云计算服务当前垄断在私人机构（企业）手中，而他们仅仅能够提供商业信用。对于政府机构、商业机构（特别像银行这样持有敏感数据的商业机构）对于选择云计算服务应保持足够的警惕。一旦商业用户大规模使用私人机构提供的云计算服务，无论其技术优势有多强，都不可避免地让这些私人机构以“数据（信息）”的重要性挟制整个社会。对于信息社会而言，“信息”是至关重要的。另一方面，云计算中的数据对于数据所有者以外的其他用户云计算用户是保密的，但是对于提供云计算的商业机构而言确实毫无秘密可言。所有这些潜在的危险，是商业机构和政府机构选择云计算服务、特别是国外机构提供的云计算服务时，不得不考虑的一个重要的前提。</p><p>云安全    云安全的策略构想是：使用者越多，每个使用者就越安全，因为如此庞大的用户群，足以覆盖互联网的每个角落，只要某个网站被挂马或某个新木马病毒出现，就会立刻被截获。云安全的发展像一阵风，瑞星、趋势、卡巴斯基、MCAFEE、SYMANTEC、</p><p>江民科技、PANDA、金山、360安全卫士、卡卡上网安全助手等都推出了云安全解决方案。</p><h2 id="厂商？"><a href="#厂商？" class="headerlink" title="厂商？"></a>厂商？</h2><p>  厂商：vmware，kvm, openstack???</p><h3 id="34-亚马逊网络服务-Amazon-Web-Service，AWS"><a href="#34-亚马逊网络服务-Amazon-Web-Service，AWS" class="headerlink" title="　　34. 亚马逊网络服务(Amazon Web Service，AWS)"></a>　　34. 亚马逊网络服务(Amazon Web Service，AWS)</h3><p>　　Amazon的AWS是一个典型的IaaS服务，他提供了一组服务，包括存储(S3)、计算能力(EC2)、消息传递(SQS)、数据集(SDB)等。有了Amazon的AWS，企业用户可以在几分钟之内迅速地获得一个基于Amazon基础设施的虚拟基础设施，并且这个基础设施是弹性的，可以根据需求扩展和收缩。世界各地的公司都可以使用这个弹性的计算基础设施。</p><p>　　35. 亚马逊 弹性计算云(Amazon Elastic Compute Cloud ，EC2)</p><p>　　Amazon Elastic Compute Cloud (EC2) 能够根据需要扩展或收缩计算资源，非常方便地提供新的服务器实例。</p><p>　　36. 亚马逊 简单存储服务( Amazon Simple Storage Service，S3)</p><p>　　Amazon Elastic Compute Cloud (EC2) 能够根据需要扩展或收缩计算资源，非常方便地提供新的服务器实例。</p><h3 id="google"><a href="#google" class="headerlink" title="google"></a>google</h3><p>37.谷歌应用程序引擎Google App Engine(GAE)</p><p>　　Google App Engine，它是PaaS应用的典型代表，也是面向开发者的。允许开发人员编写应用程序，然后把应用构建在Google的基础架构上。App Engine方便用户开发新的服务逻辑，并且在云计算平台上运行这些新的服务。</p><h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><h3 id="首都在线"><a href="#首都在线" class="headerlink" title="首都在线"></a>首都在线</h3><h3 id="世纪互联"><a href="#世纪互联" class="headerlink" title="世纪互联"></a>世纪互联</h3><p>云主机</p><p>　　CloudEx 云主机是世纪互联集团成员云快线公司推出的将计算、存储与网络资源整合一体的互联网服务器租用服务， 解决了传统物理租机与VPS存在的管理难度大，业务扩展性弱的缺陷，降低了传统的物理主机租用的成本，并无需支付押金。CloudEX云主机拥有客户自服务管理手段，可自主实现对主机远程管理与维护，降低了客户获得计算能力的成本，简化了服务器管理过程，还可根据客户配置需求变化而弹性扩充，从而实现主机配置的快速扩容。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>云安全<br>云安全(Cloud Security)是一个从“云计算”演变而来的新名词。云安全的策略构想是：使用者越多，每个使用者就越安全，因为如此庞大的用户群，足以覆盖互联网的每个角落，只要某个网站被挂马或某个新木马病毒出现，就会立刻被截获。<br>“云安全”通过网状的大量客户端对网络中软件行为的异常监测，获取互联网中木马、恶意程序的最新信息，推送到Server端进行自动分析和处理，再把病毒和木马的解决方案分发到每一个客户端。</p><p>云存储<br>云存储是在云计算(cloud computing)概念上延伸和发展出来的一个新的概念，是指通过集群应用、网格技术或分布式文件系统等功能，将网络中大量各种不同类型的存储设备通过应用软件集合起来协同工作，共同对外提供数据存储和业务访问功能的一个系统。 当云计算系统运算和处理的核心是大量数据的存储和管理时，云计算系统中就需要配置大量的存储设备，那么云计算系统就转变成为一个云存储系统，所以云存储是一个以数据存储和管理为核心的云计算系统。</p><p>云游戏<br>云游戏是以云计算为基础的游戏方式，在云游戏的运行模式下，所有游戏都在服务器端运行，并将渲染完毕后的游戏画面压缩后通过网络传送给用户。在客户端，用户的游戏设备不需要任何高端处理器和显卡，只需要基本的视频解压能力就可以了。 就现今来说，云游戏还并没有成为家用机和掌机界的联网模式，因为至今X360仍然在使用LIVE，PS是PS NETWORK ，wii是wi-fi。但是几年后或十几年后，云计算取代这些东西成为其网络发展的终极方向的可能性非常大。 如果这种构想能够成为现实，那么主机厂商将变成网络运营商，他们不需要不断投入巨额的新主机研发费用，而只需要拿这笔钱中的很小一部分去升级自己的服务器就行了，但是达到的效果却是相差无几的。对于用户来说，他们可以省下购买主机的开支，但是得到的确是顶尖的游戏画面（当然对于视频输出方面的硬件必须过硬。）。你可以想象一台掌机和一台家用机拥有同样的画面，家用机和我们今天用的机顶盒一样简单，甚至家用机可以取代电视的机顶盒而成为次时代的电视收看方式。[8]<br>云计算</p><h1 id="给使用者带来的好处"><a href="#给使用者带来的好处" class="headerlink" title="给使用者带来的好处"></a>给使用者带来的好处</h1><p>云计算出现之前</p><p>在云计算解决方案出现之前，传统的业务应用程序不仅十分复杂，而且成本高昂。企业正常运行所需的各种软硬件也是数量惊人，种类繁杂。您甚至需要一整个专家团队来负责软件的安装、配置、测试、运行、保护和更新。</p><p>而假如您面对的是数十、甚至数以百计的应用程序，则程序运维所需的人力与成本会成倍增加。这也是为什么那些规模庞大的公司即使拥有最优秀的 IT 部门，也仍然无法获得应用程序最佳的运营效果。对于中小型公司来说，更是难以负担如此的巨大成本。</p><p>云计算简单高效<br>云计算提供高效的解决方案</p><p>云计算的出现让各大小企业看到了希望。通过云计算平台，您无需再为各个软硬件的升级而烦恼，所有这一切都可以交给像Salesforce这样经验丰富的云计算服务供应商来处理。在云服务平台上，使用共享的基础设施就像使用水电一样：您用多少就付多少费用，而平台的软硬件升级对您来说是自动的。这样，也更方便您按企业需求来扩大或缩小服务范围。</p><p>只需要几天或几周的时间，基于云计算平台的应用程序即可完成安装部署并投入运行。相对而言，云计算平台的应用程序比传统的软件占用更少的成本。运行云计算应用程序，您只需打开浏览器、登录、自定义选项设置，即可开始使用。</p><p>企业通过在云端运行的各种应用程序完成各项任务，比如客户关系管理(CRM)、销售团队管理、财务等等。在经过严格的基础设施安全性和可靠性测试后，一些世界顶级公司将他们的应用程序移至Salesforce的云端平台。</p><p>云计算移动性和协作能力更好<br>云计算提升程序移动性和协作能力</p><p>云计算的最新创新是让我们的商业应用程序具备更强的移动性和协作能力，就像Facebook和Twitter等深受欢迎的定制型应用。作为用户，我们期望自己关心的信息能够实时推送到我们的面前，而云计算模式的业务应用程序正在努力朝这个方向发展。有了云计算服务，管理您工作中的一切就像使用Facebook管理您的个人生活一样简单。</p><h2 id="基于云计算的应用"><a href="#基于云计算的应用" class="headerlink" title="基于云计算的应用"></a>基于云计算的应用</h2><p>使用了云计算</p><p>　　45. 云杀毒</p><p>　　云杀毒其实还是基于特征码杀毒，只是杀软的病毒库已经不全部在本地了，而是在一大堆的服务器里，扫描的时候和服务器交互，这样来做出判断是否有病毒。云杀毒能降低升级的频率，降低查杀的占用，减小本地库的容量。</p><p>　　46. 云备份</p><p>　　作为一种全新的基于宽带互联网、大容量存储空间的备份服务，云备份破茧而生，简而言之，它就是通过集群应用、网格技术或分布式文件系统等功能，将网络中大量各种不同类型的存储设备通过应用软件集合起来协同工作，共同对外提供数据存储备份和业务访问的功能服务。</p><p>　　兴建一个云备份基础设施的费用将是数以百万计的，并需要大量的技术支持，所以，云备份服务的门槛一直较高，在国外，由于互联网起步较早，网络宽带发展迅速，云备份时代已步入成熟阶段，即便如此，能够提供此服务的也只有少数IT巨头，亚马逊、EMC、Carbonite、赛门铁克等，其中亚马逊在该领域取得了公认的市场成功。</p><p>　　纵观国内市场，网络宽带的迅速发展和互联网应用的普及，数据灾难备份需求如井喷般爆发，在少数创新技术及企业的推进下，国内云备份市场开始初见规模，但由于该领域门槛较高，目前身居行业第一阵营、能与国外同行业相媲美的只有通信龙头企业中国电信、著名互联网基础设施服务提供商世纪互联、国内知名电脑生产商联想等。</p><p>　　47. 云迁移</p><p>　　云迁移指的是企业从传统的平台向云平台的迁移，因为与传统的应用平台相比，云计算平台的优点在于强大的计算能力、存储能力、多样化的服务以及高性价比。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="云计算是什么？-云计算入门必备的60条术语"><a href="#云计算是什么？-云计算入门必备的60条术语" class="headerlink" title="云计算是什么？ 云计算入门必备的60条术语"></a>云计算是什么？ 云计算入门必备的60条术语</h2><ol><li>云计算</li></ol><img src="/2017/10/24/cloud_computing.html/cloud1.jpg" alt="cloud1.jpg" title=""><p>关于云计算的定义，目前为止至少有不下20种，这里选择了一种比较常见的定义：</p><p>【提供者角度】<br>云计算，是分布式计算技术的一种，其最基本的概念，<br>是透过网络将庞大的计算处理程序自动分拆成无数个较小的子程序，再交由多部服务器所组成的庞大系统经搜寻、<br>计算分析之后将处理结果回传给用户。透过这项技术，网络服务提供者可以在数秒之内，<br>达成处理数以千万计甚至亿计的信息，达到和“超级计算机”同样强大效能的网络服务。</p><p>【使用者角度】<br>云计算是一种资源交付和使用模式，指通过网络获得应用所需的资源(硬件、平台、软件)。<br>提供资源的网络被称为“云”。“云”中的资源在使用者看来是可以无限扩展的，并且可以随时获取。<br>这种特性经常被比喻为像水电一样使用硬件资源，按需购买和使用。</p><h1 id="相关问题-即机遇"><a href="#相关问题-即机遇" class="headerlink" title="相关问题(即机遇)"></a>相关问题(即机遇)</h1><p>数据隐私问题：如何保证存放在云服务提供商的数据隐私不被非法利用，不仅需要技术的改进，也需要法律的进一步完善<br>数据安全性：有些数据是企业的商业机密，数据的安全性关系到企业的生存和发展。云计算数据的安全性问题解决不了会影响云计算在企业中的应用。<br>用户的使用习惯：如何改变用户的使用习惯，使用户适应网络化的软硬件应用是长期而且艰巨的挑战。<br>网络传输问题：云计算服务依赖网络，2013年网速低且不稳定，使云应用的性能不高。云计算的普及依赖网络技术的发展。<br>缺乏统一的技术标准：云计算的美好前景让传统IT厂商纷纷向云计算方向转型。但是由于缺乏统一的技术标准，尤其是接口标准，各厂商在开发各自产品和服务的过程中各自为政，这为将来不同服务之间的互连互通带来严峻挑战。</p><h1 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h1><h2 id="Amazon-EC2"><a href="#Amazon-EC2" class="headerlink" title="Amazon EC2"></a>Amazon EC2</h2><p><a href="https://www.amazonaws.cn/ec2/" target="_blank" rel="external">https://www.amazonaws.cn/ec2/</a></p><h2 id="又拍云"><a href="#又拍云" class="headerlink" title="又拍云"></a>又拍云</h2><p><a href="https://www.upyun.com/" target="_blank" rel="external">https://www.upyun.com/</a></p><p>CDN<br>跨地区、跨运营商覆盖的内容分发网络<br>直播云<br>超低延迟、高码率和大并发的音视频直播服务<br>云存储<br>海量、安全和高可靠的云存储服务<br>点播云<br>安全稳定、弹性和高可用的音视频点播服务<br>云处理<br>简单、灵活并支持多终端的云处理服务<br>短视频<br>集短视频采集、存储、分发、播放的整体解决方案<br>流量营销服务<br>三网通用、超低成本并可快速开展的营销服务<br>SSL 证书服务<br>申购、管理一站式服务，快速实现全站 HTTPS<br>短信服务<br>提供企业级短信送达服务，三网合一，到达率高<br>内容识别<br>高准确率的直播、点播、图片色情识别服务</p><h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><ul><li><p>电厂模式（现在公有云的主要商业模式）<br>利用电厂的规模效应，来降低电力的价格，并让用户使用起来更方便。<br>规模效应凸显，小厂商很难有机会。</p></li><li><p>效用计算（共享云？）<br>1961年，人工智能之父麦肯锡在一次会议上提出了“效用计算”这个概念。目标是整合分散在各地的服务器、存储系统以及应用程序来共享给多个用户，根据用户的使用量来付费。<br>不容易实现。</p><p>p2p下载？</p></li><li><p>网格计算模式<br>网格计算研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，然后把这些部分分配给许多低性能的计算机来处理，最后把这些计算结果综合起来攻克大问题。<br>重点放在解决“计算力”上面。<br>不是所有的计算问题都能分解，或者很难分解。</p><p>一个童话般的案例：“在家寻找外星人”项目</p><p>加州大学伯克利分校空间科学实验室负责组织实施，NASA资助<br>1999年5月17日开始正式运行</p><p>利用全球联网的计算机共同搜寻外星人的科学实验。<br>参与者下载运行一个程序，从空间科学实验室下载Arecibo射电望远镜采集的海量数据的片段，在计算机空闲时进行分析，然后将分析结果上传。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念篇&quot;&gt;&lt;a href=&quot;#概念篇&quot; class=&quot;headerlink&quot; title=&quot;概念篇&quot;&gt;&lt;/a&gt;概念篇&lt;/h1&gt;&lt;h2 id=&quot;云计算是什么&quot;&gt;&lt;a href=&quot;#云计算是什么&quot; class=&quot;headerlink&quot; title=&quot;云计算是什么&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习总结</title>
    <link href="http://holbrook.github.io/2017/10/13/machine-learning/ML_index.html"/>
    <id>http://holbrook.github.io/2017/10/13/machine-learning/ML_index.html</id>
    <published>2017-10-12T16:00:00.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>小结。</p><a id="more"></a><h1 id="机器学习的本质"><a href="#机器学习的本质" class="headerlink" title="机器学习的本质"></a>机器学习的本质</h1><p>这个问题在<a href="http://www.zhihu.com/question/19830921" target="_blank" rel="external">知乎</a>上有很多讨论，但似乎没有达成共识。我个人的观点如下：</p><p>机器学习的目标是让计算机自动获取知识，然后用获取的知识解决问题。</p><p>获取知识的方式是通过大量的数据，得到一个函数。</p><p>从程序的角度来说，传统的程序在编码完成时，函数就已经确定了，运行程序就是执行这个函数，其结果是确定的；<br>而机器学习程序在编码完成后，需要先用数据进行训练/学习，才能确定函数形式，执行这个函数的结果取决于<br>训练/学习的数据，是不确定的。</p><p>机器学习得到的函数可能是基于概率的(基于统计学习)，也可能是确定的函数关系。</p><p>从数学角度，机器学习与生物学习的过程本质上是一样的，都是映射。机器学习得到的函数就是这种映射关系的体现。<br>而映射关系从数学上来讲，就是空间搜索和函数的泛化。需要从数据中过滤噪声(noise),提取事物的特征(feature)，<br>最后通过特征(feature)确定映射关系。</p><h2 id="输入空间、特征空间和输出空间"><a href="#输入空间、特征空间和输出空间" class="headerlink" title="输入空间、特征空间和输出空间"></a>输入空间、特征空间和输出空间</h2><p>输入空间和输出空间其实就是输入和输出所有可能取值的集合。<br>输入和输出空间可以是有限元素的集合，也可以是整个欧式空间。<br>输入空间和输出空间可以是一个空间，也可以是不同的空间；通常情况下，输出空间要远远小于输入空间。</p><p>特征空间是所有特征向量存在的空间。特征空间的每一维对应于一个特征。<br>有时假设输入空间与特征空间为相同的空间，对它们不予区分；<br>有时假设输入空间与特征空间为不同的空间，将实例从输入空间映射到特征空间。模型实际上都是定义在特征空间上的。</p><h1 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h1><h2 id="按照输入空间分类"><a href="#按照输入空间分类" class="headerlink" title="按照输入空间分类"></a>按照输入空间分类</h2><p>根据输入空间的数据类型，可以分为：</p><ul><li><p>具体特征（Conctrete Feature）</p><p>输入X的每一维特征都被人类进行的整理和分析，这种分析常常是与专业领域关联的。</p><p>比如对硬币分类需要的特征是（大小，重量）；对信用分级需要的特征是客户的基本信息。<br>这些特征中已经蕴含了人的思考。</p></li><li><p>原始特征（Raw Features）</p><p>需要人或者机器（深度学习，Deep Learning）进行转化，将原始特征转化成为具体的特征，<br>在机器视觉和声音信号的辨识都是属于该类。</p><p>例如，数字识别中，原始特征是图片的像素矩阵；声音识别中的声波信号；机器翻译中的每个单词。</p><p>其中，深度学习是通过机器自动的进行特征提取的。<br>它需要有大量的资料或者非监督式学习的方式去学习如何从中抽取出非常具体的特征。<br>深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。</p></li><li><p>抽象特征（Abstract Feature）</p><p>抽象特征通常没有任何真实意义，更需要认为地进行特征转化、抽取和再组织。</p><p>例如，预测某用户对电影的评分，原始数据是(userid, itemid, rating)，<br>rating 是训练数据的标签，相当于y。<br>这里的(userid, itemid)本身对学习任务是没有任何帮助的，<br>我们必须对数据所进一步处理、提炼、再组织。</p></li></ul><p>离散特征具有丰富的自然含义；原始特征有简单的自然含义；抽象特征没有自然含义。</p><p>离散特征一般只需要简单选取就够了，<br>原始特征、抽象特征都需要再处理，此过程称为特征工程(feature engineering)，<br>是机器学习、数据挖掘中及其重要的一步。</p><h2 id="按照输出空间分类"><a href="#按照输出空间分类" class="headerlink" title="按照输出空间分类"></a>按照输出空间分类</h2><ul><li><p>二值分类 Classification）问题</p><p>即“是非问题(say YES/NO)”，其输出空间Y={-1，+1}</p><p>二类分类应用非常广泛，比如判断是否为垃圾邮件、广告投资是否能盈利、学习系统上在下一题答题是否正确。<br>二类分类在机器学习中地位非常重要，是其他算法的基础。</p></li><li><p>多值分类 Classification）问题</p><p>输出空间为有限个类别： Y={1,2，…,K}</p><p>多类别分类的应用，比如根据一张图片，得出图片中是苹果、橘子还是草莓等；<br>还有像Google邮箱，将邮件自动分成垃圾邮件、重要邮件、社交邮件、促销邮件等。<br>多类别分类在视觉或听觉的辨识中应用很广泛。</p></li><li><p>回归问题（Regression）</p><p>输出空间为实数范围( Y= R ) ，或区间 (Y = [lower, upper] )。 输出是无限种可能。</p><p>回归分析在股票价格预测和天气气温的预测上被广泛应用。</p></li><li><p>结构学习问题（Structured Learning）/序列标记（Sequence Tagging）问题</p><p>输出是一个结构化数据(structures)，比如句子中每个单词的词性。<br>可以成为 hyperclass， 通常难以显示地定义该类。</p><p>该学习模型也可以看做是多类别学习的一种，这里可能涉及到数量很大的类别。</p><p>在自然语言处理中，自动的词性标注是很典型的结构学习的例子。比如给定机器一个句子，由于词语在不同的句子当中可能会有不同的词性，所以该方法是用来对句子的结构特性的理解。这种学习方法可以被看做是多类别分类，但与多类别分类不同的是，其目标的结构种类可能规模很大，其类别是隐藏在句子的背后的。</p><p>这种结构学习的例子还有例如说，生物中蛋白质3D立体结构，自然语言处理方面。</p><p>结构学习在有些地方被描述成标注（tagging）问题，标注问题的输入是一个观测序列，输出是一个标记序列或状态序列。标注问题的目标在于学习一个模型，使它能够对观测序列给出标记序列作为预测。</p></li></ul><h2 id="按照应用类型"><a href="#按照应用类型" class="headerlink" title="按照应用类型"></a>按照应用类型</h2><ul><li>关联</li><li>回归(Regression)</li><li><p>密度估计(Density Estimation)</p><p>输出是一个概率密度函数或者概率函数。可以近似看做无监督的有界回归问题。</p><p>典型例子是根据位置的交通情况报告，预测事故危险多发的区域。</p></li><li><p>分类(Classification)</p></li><li><p>聚类(Clustering)</p><p>数据的类别是不知道的，根据某种规则得到不同的分类。可以近似看做无监督的多类别分类。</p><p>比如将网络上各式各样的文章分成不同的主题;<br>商业公司根据不同的顾客的资料，将顾客分成不同的族群。</p></li><li><p>异常检测(Outlier Detection）</p><p>可以看做近似的无监督二类分类问题。</p><p>比如根据网络的日志的情况，检测是否有异常入侵行为，这是一个极端的“是非题”，可以用非监督的方法来得出。</p></li><li><p>预测</p></li><li><p>时间序列</p></li><li><p>智能优化</p></li></ul><h2 id="训练-学习方式"><a href="#训练-学习方式" class="headerlink" title="训练/学习方式"></a>训练/学习方式</h2><p>根据学习的方式，可以分为有监督学习和无监督学习。其中有监督学习，需要训练数据中已经人工做好标签(Label)。<br>另外，还有介于二者之间的半监督学习，以及通过结果进行反馈的增强学习。</p><ul><li><p>有监督学习(Supervised Learning)</p><p>有监督学习需要训练数据，训练数据中每个样本都包含人工做好的标签(Label)。<br>在建立预测模型的时候，监督式学习建立一个学习过程，<br>将预测结果与“训练数据”的实际结果进行比较，不断的调整预测模型，直到模型的预测结果达到一个预期的准确率。</p><p>监督学习常用于分类问题和回归问题。</p></li><li><p>无监督学习（Unsupervised Learning）</p><p>训练数据中没有特别的标识，通过学习推断出数据的一些内在结构。</p><p>无监督学习常用于关联，聚类，密度估计(density estimation),异常检测。</p></li><li><p>半监督学习（Semi-Supervised Learning)</p><p>半监督学习是监督学习与无监督学习相结合的一种学习方法，<br>主要考虑如何利用少量的标注样本和大量的未标注样本进行训练和分类的问题。</p><p>半监督学习的输入数据中，只有少量标注数据，算法利用未标记的大量数据提升机器学习算法的表现效果。</p><p>这类学习模型可以用来进行预测，<br>但是模型首先需要学习数据的内在结构以便合理的组织数据来进行预测。</p><p>半监督学习的算法一般是对监督式学习算法的延伸，也常用于分类问题和回归问题。主要有五类：</p><ol><li>基于概率的算法；</li><li>在现有监督算法基础上作修改的方法；</li><li>直接依赖于聚类假设的方法；</li><li>基于多视图的方法；</li><li>基于图的方法。</li></ol><p>这些算法首先试图对未标识数据进行建模，在此基础上再对标识的数据进行预测。<br>如图论推理算法（Graph Inference）或者拉普拉斯支持向量机（Laplacian SVM.）等。</p><p>半监督学习的例子，比如人脸识别，可能只有一小部分人脸是被标记的，大部分是没有被标记的。</p></li><li><p>增强学习（Reinforcement Learning）</p><p>增强学习，通常知识是隐含的，无法直接表示什么是正确的。<br>学习的方法是通过”惩罚“不好的结果，”奖励“好的结果来优化学习效果。</p><p>增强学习是一种以环境反馈作为输入的、特殊的、适应环境的机器学习方法。<br>所谓强化学习是指从环境状态到行为映射的学习，以使系统行为从环境中获得的累积奖赏值最大。<br>该方法不同与监督学习技术那样通过正例、反例来告知采取何种行为，<br>而是通过试错（trial-and-error）的方法来发现最优行为策略。</p><p>在这种学习模式下，输入数据不是像监督模型那样作为对模型的反馈，<br>而是作为一个检查模型对错的方式。输入数据直接反馈到模型，模型必须对此立刻作出调整。</p><p>增强学习的的输出不一定是真正想要得到的输出，而是用过奖励或者惩罚的方式来告诉这个系统做的好还是不好。</p><p>增强学习是一种”困难“但是非常自然的方式进行学习。常用于广告系统，扑克、棋类游戏，动态系统以及机器人控制等。</p><p>比如一个线上广告系统，可以看做是顾客在训练这个广告系统。这个系统给顾客投放一个广告，<br>即可能的输出，而顾客有没有点或者有没有因为这个广告赚钱，这评定了这个广告投放的好坏。<br>这就让该广告系统学习到怎么样去放更适合的广告。</p><p>常见算法包括Q-Learning以及时间差学习（Temporal difference learning）</p></li></ul><p>在企业数据应用的场景下， 人们最常用的可能就是监督式学习和非监督式学习的模型。<br>在图像识别等领域，由于存在大量的非标识的数据和少量的可标识数据，目前半监督式学习是一个很热的话题。 而强化学习更多的应用在机器人控制及其他需要进行系统控制的领域。</p><h2 id="根据学习协议（Protocol）分类"><a href="#根据学习协议（Protocol）分类" class="headerlink" title="根据学习协议（Protocol）分类"></a>根据学习协议（Protocol）分类</h2><ul><li><p>批量学习(Batch learning)</p><p>”填鸭式“（duck feeding）, 将所有已知训练数据一次性批量输入给学习算法。</p></li><li><p>在线学习(online learning)</p><p>”循序渐进式“（passive sequential）,通过序列化地接收数据，循序渐进地学习，逐渐提高性能。</p><p>应用：垃圾邮件， 增强学习。</p></li><li><p>主动学习(active learning/learning by asking)</p><p>”提问式“（question asking）。可以看做是机器有问问题的能力。<br>开始只有少量label, 通过有策略地”问问题“ 来提高性能。<br>比如遇到xi, 不确定输出是否正确，则主动去确认yi 是什么，依次来提高性能。</p><p>当label的获取成本非常昂贵时，会利用此法。</p><p>比如电子相册中好友照片的标注，需要机器向人提问。</p></li></ul><h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><table><thead><tr><th style="text-align:left">算法</th><th style="text-align:center">学习方式</th><th style="text-align:center">输入空间</th><th style="text-align:center">特征空间</th><th style="text-align:center">输出空间</th><th style="text-align:center">解决的问题</th><th style="text-align:center">应用场景</th><th style="text-align:center">条件</th><th style="text-align:right">局限性</th></tr></thead><tbody><tr><td style="text-align:left">决策树</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">分类回归树</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">朴素贝叶斯</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">线性判别分析</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">K邻近</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">逻辑斯谛回归</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">径向基函数网络</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">对偶传播网络</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">学习向量量化网络</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">误差反向传播网络</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">支持向量机(SVM)</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">单层感知器</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">双隐藏层感知器</td><td style="text-align:center">有监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">KMeans</td><td style="text-align:center">无监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">CHAMELONE</td><td style="text-align:center">无监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">BIRCH</td><td style="text-align:center">无监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">DBScan</td><td style="text-align:center">无监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">EM算法(高斯混合)</td><td style="text-align:center">无监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">谱聚类</td><td style="text-align:center">无监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">自组织映射网络</td><td style="text-align:center">无监督</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">FP-Tree</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">主成分分析</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">Apriori算法</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">k-Means算法</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">逻辑回归</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td style="text-align:left">反向传递神经网络</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://www.zhihu.com/question/19830921" target="_blank" rel="external">机器学习的本质是什么</a> , 知乎</li><li><a href="http://blog.csdn.net/jasonding1354/article/details/41720303" target="_blank" rel="external">机器学习算法的分类</a>, Jason Ding, CSDN</li><li><a href="http://www.cnblogs.com/zhangchaoyang/archive/2012/08/28/2660929.html" target="_blank" rel="external">机器学习问题方法总结</a>, Orisun, 博客园</li><li><a href="http://www.cnblogs.com/geniferology/p/what_is_machine_learning.html" target="_blank" rel="external">什么是机器学习</a>, Cybernetic1, 博客园</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小结。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://holbrook.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://holbrook.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《量化投资：数据挖掘技术与实践(MatLab版)》读书笔记第7章：分类方法</title>
    <link href="http://holbrook.github.io/2017/10/12/quant/quantitative_investment/quantitative_investment7.html"/>
    <id>http://holbrook.github.io/2017/10/12/quant/quantitative_investment/quantitative_investment7.html</id>
    <published>2017-10-11T16:00:00.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p> 分类算法通过对已知类别训练集的分析，从中发现分类规则，以此预测新数据的类别。</p><a id="more"></a><p><a href="!--￼0--">《量化投资：数据挖掘技术与实践(MatLab版)》读书笔记目录</a></p><p>分类算法通过对已知类别训练集的分析，从中发现分类规则，以此预测新数据的类别。</p><p>首先选择一个分类算法，然后用训练集(Training Set)进行训练，归纳出学习模型。<br>将新模型用测试集进行验证，验证通过的模型就可以用于预测了。</p><p>分类算法有很多，常用的有以下几种：</p><ul><li>K-近邻（KNN）</li><li>贝叶斯分类</li><li>神经网络</li><li>逻辑斯蒂（Logistic）</li><li>判别分析</li><li>支持向量机（SVM）</li><li>决策树</li></ul><h1 id="K-近邻（K-Nearest-Neighbors-KNN）"><a href="#K-近邻（K-Nearest-Neighbors-KNN）" class="headerlink" title="K-近邻（K-Nearest Neighbors, KNN）"></a>K-近邻（K-Nearest Neighbors, KNN）</h1><p>K-近邻算法，把每个样例看做d维空间上的一个点, d是属性的个数。</p><p>对于给定的样例，取d维空间中预期距离最近的K个训练样例，取这K个训练样例所标记的类别中的多数者，<br>作为该给定样例的类别。</p><p>KNN算法的有效性依赖于K的选取。K太小，预测不稳定；K太大，容易误判。<br>从原理上来说，数据的有效参数个数约等于 n/K, 其中 n 是训练集中的样本个数。<br>实际操作中，需要通过反复实验来确定分类误差率最小的K值。</p><p>KNN算法的优点是可以较好的避免样本不平衡问题；对于分类交叉/重叠较多的情况也更适用。</p><p>缺点是计算量大，解决办法是剔除作用不大的训练样本，或者对样本进行分层分类。</p><h1 id="贝叶斯分类"><a href="#贝叶斯分类" class="headerlink" title="贝叶斯分类"></a>贝叶斯分类</h1><p>贝叶斯(Bayes)分类是一类以贝叶斯定理为基础的基于概率统计知识的分类算法的总称。</p><p>贝叶斯定理：事件A在事件B(发生)的条件下的概率，与事件B在事件A的条件下的概率不一样，<br>但是二者有确定的关系：</p><p>$P(Y|X)=\frac{P(X|Y) P(Y)}{P(X)}$</p><p>其中：</p><ul><li>P(Y=y|X=x) 后验概率， 是在 X=x 的条件下， Y=y 发生的概率</li><li>P(Y): 先验概率</li><li>P(X|Y): 条件概率</li><li>P(X): 证据</li></ul><p>贝叶斯定理可以用 先验概率、条件概率和证据，计算出后验概率。</p><p>贝叶斯分类中最简单的是朴素贝叶斯分类。其思想是：对于给出的待分类项，求解在此项出现的条件下，<br>各个类别出现的概率。概率最大的概率作为待分类项的类别。</p><p>朴素贝叶斯(NB)分类是最优秀的分类器之一，基于类条件独立假设(朴素假设)：</p><p>   给定类节点(变量)后，各属性节点(变量)之间互相独立。</p><p>根据朴素假设，则有：</p><p>$P(X|{C}<em>{i})= \prod</em>{k=1}^{m}P({X}<em>{k}|{C}</em>{i})$</p><p>其中，条件概率 $ P(X1|{C}<em>{i}) , P(X2|{C}</em>{i}) … P(Xn|{C}<em>{i}) $<br>可以从训练集数据中求得。于是可以计算出X属于每一个类别 Ci 的概率<br>$ P(X|{C}</em>{i}) P({C}_{i}) $</p><p>从上述原理可以看出，朴素贝叶斯分类的三个步骤：</p><ol><li><p>准备工作</p><p>根据具体情况确定特征属性，并对每个特征属性进行划分，人工分类，形成训练样本集合。</p><p>分类器的质量，很大程度由特征属性、特征属性划分、训练样本质量绝对。</p></li><li><p>分类器训练</p><p>计算每个类别在训练样本中出现的频度， 以及每个特征属性划分对每个类别的条件概率估计，并记录结果。</p></li><li><p>应用</p><p>输入待分类项，输出待分类项与类别的映射关系。</p></li></ol><p>朴素贝叶斯算法成立的前提是各属性相互独立。其方法简单，准确率高，速度快，可以与决策树和神经网络媲美。</p><p>朴素贝叶斯分类能够适应孤立的噪声点，也可以处理属性值遗漏的问题。</p><p>实际情况中，往往独立性假设不成立，其准确性会下降。此时可以使用一些改进算法，比如<br>TAN(Tree Augmented Bayes Network)算法， 贝叶斯网络分类器(Bayesian Network Classifier, BNC)等。</p><h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p>人工神经网络(Artificial Neural Networks, ANN)是一种应用类似于大脑神经突触联接的结构进行<br>信息处理的属性模型。通过模拟脑细胞在同一个脉冲反复刺激下能够改变神经元之间的神经键连接强度的特性<br>进行学习。</p><p>ANN由一组相互连接的节点和有向链构成。其结构单元是感知器(perceptron)。每个感知器有多个输入节点<br>和一个输出节点。感知器对输入节点进行加权，计算输出信号。这个权重就是用来模拟神经元之间的连接强度。</p><p>对感知器的训练，就是通过输入数据不断调整链的权重，直到能拟合训练数据。</p><p>用公式表示感知器的模型如下：</p><p>$ \hat{y}=sign(wx-t) $</p><p>其中， w是权值向量， x是输入向量， t是偏置因子。</p><p>用于分类的神经网络模型常见的有：</p><ul><li>BP(Back Propagation)神经网络</li><li>RBF网络</li><li>Hopfield网络</li><li>自组织特征映射神经网络</li><li>学习矢量化神经网络</li></ul><p>目前应用较多的时BP神经网络。神经网络的主要缺点是收敛速度慢，计算量大，训练时间长，结果不可解释。</p><h1 id="逻辑斯蒂（Logistic）"><a href="#逻辑斯蒂（Logistic）" class="headerlink" title="逻辑斯蒂（Logistic）"></a>逻辑斯蒂（Logistic）</h1><p>逻辑斯蒂分类，其实就是前面的<a href="{filename}quantitative_investment6.md#logistichui-gui">逻辑斯蒂回归</a></p><h1 id="判别分析"><a href="#判别分析" class="headerlink" title="判别分析"></a>判别分析</h1><p>判别分析(Discriminant Analysis, DA), 根据案例的分组变量和特征变量，确定分组变量和特征变量之间的<br>数量关系，以此建立判别函数(Discriminant Function)。然后利用判别函数对新案例进行分类。</p><p>判别分析的假设条件：</p><ul><li>每个判别变量不能是其他判别变量的线性组合</li><li>每组案例的协方差矩阵相等</li><li>各判别变量之间具有多元正态分布，即每个变量对于其他所有变量的固定值具有正态分布</li></ul><p>判别函数为以下线性函数关系：</p><p>$ y={b}<em>{0} + {b}</em>{1} {x}<em>{1} + … + {b}</em>{k} {x}_{k} $</p><p>其中：</p><ul><li>y 是判别值(Discriminant Score)</li><li>$ {x}_{i} $ 为各个判别变量</li><li>$ {b}_{i} $ 为判别系数(Discriminant Coefficient or Weight)</li></ul><p>判别模型的各个判别变量可以看做 k 维空间，每个案例是空间中的一点。相同分类的点聚集成一组，<br>该组的中心点用该组中各个案例的平均值代表。</p><h1 id="支持向量机（SVM）"><a href="#支持向量机（SVM）" class="headerlink" title="支持向量机（SVM）"></a>支持向量机（SVM）</h1><p>支持向量机(Support Vector Machine, SVM)，是建立在统计学习理论基础上的机器学习方法，<br>属于有监督学习。</p><p>SVM 在多维空间中构建一个超平面，使得这个超平面能够划分训练数据中的两类节点，并且每一个点<br>到这个超平面的距离足够大，则这个超平面可以作为分类依据。</p><p>这个超平面叫做决策边界，每个数据点垂直指向这个平面的向量叫做支持向量。</p><p>对于多类划分，需要构建多个超平面。</p><p>对于线性SVM，假设训练样本集 $ {({x}<em>{i},{y}</em>{i}), i=1,2,…,n } $ 有两个类别:<br>y=1 和 y=-1 。</p><p>如果存在分类超平面:</p><p>$ {w}^{T} x + b = 0 $</p><p>能够将样本正确分为两类(相同类别的样本都落在分类超平面的同一侧)，则称该样本集是线性可分的，即满足：</p><p>$ \begin{cases}<br> &amp; \text{ if {w}^{T} {x}<em>{i} + b \geq 1 } {y}</em>{i} = 1  \<br> &amp; \text{ if {w}^{T} {x}<em>{i} + b \leq -1 } {y}</em>{i} = -1<br>\end{cases} $</p><p>此时 $ {w}^{T} {x}<em>{i} + b =1 $ 和 $ {w}^{T} {x}</em>{i} + b =-1 $<br>这两个平行的平面称为该分类问题的边界超平面。</p><p>SVM要求解距离最大 (距离的倒数最小) 的两个边界平面，即最佳超平面。即：</p><p>$<br>min: \frac{1}{2} \begin{Vmatrix} w \end{Vmatrix} = \frac{1}{2} \sqrt{ {w}^{T} w } \<br>s.t. {y}<em>{i} ({w}^{T} {x}</em>{i} + b )  \geq 1 , i=1,2,…,n<br>$</p><p>这是一个二次优化问题 —— 目标函数是二次的，约束条件是线性的。可以用拉格朗日变换求解。</p><p>（过程：略）</p><p>对于线性不可分隔的情况，可以使用核函数，将其映射到线性可分的空间再进行求解。</p><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><h1 id="分类的评判"><a href="#分类的评判" class="headerlink" title="分类的评判"></a>分类的评判</h1><h1 id="应用实例：分类选股法"><a href="#应用实例：分类选股法" class="headerlink" title="应用实例：分类选股法"></a>应用实例：分类选股法</h1><h1 id="延伸阅读：其他分类方法"><a href="#延伸阅读：其他分类方法" class="headerlink" title="延伸阅读：其他分类方法"></a>延伸阅读：其他分类方法</h1><h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><p><a href="{filename}quantitative_investment_index.md">《量化投资：数据挖掘技术与实践(MatLab版)》读书笔记目录</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 分类算法通过对已知类别训练集的分析，从中发现分类规则，以此预测新数据的类别。&lt;/p&gt;
    
    </summary>
    
      <category term="量化交易" scheme="http://holbrook.github.io/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/"/>
    
    
      <category term="数据分析" scheme="http://holbrook.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="读书笔记" scheme="http://holbrook.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《量化投资：数据挖掘技术与实践(MatLab版)》读书笔记 目录</title>
    <link href="http://holbrook.github.io/2017/10/12/quant/quantitative_investment/quantitative_investment_index.html"/>
    <id>http://holbrook.github.io/2017/10/12/quant/quantitative_investment/quantitative_investment_index.html</id>
    <published>2017-10-11T16:00:00.000Z</published>
    <updated>2017-10-26T10:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p> 目录和总结</p><a id="more"></a><p><a href="https://book.douban.com/subject/26415529/" target="_blank" rel="external">《量化投资：数据挖掘技术与实践（MATLAB版）》</a></p><ul><li><p>第一篇 基础篇</p><ul><li><a href="{filename}quantitative_investment1.md">第1章 绪论</a></li><li><a href="{filename}quantitative_investment2.md">第2章 数据挖掘的内容、过程及工具</a></li></ul></li><li><p>第二篇 技术篇</p><ul><li><a href="{filename}quantitative_investment3.md">第3章 数据的准备</a></li><li><a href="{filename}quantitative_investment4.md">第4章 数据的探索</a></li><li><a href="{filename}quantitative_investment5.md">第5章 关联规则方法</a></li><li><a href="{filename}quantitative_investment6.md">第6章 数据回归方法</a></li><li><a href="{filename}quantitative_investment7.md">第7章 分类方法</a></li><li><a href="{filename}quantitative_investment8.md">第8章 聚类方法</a></li><li><a href="{filename}quantitative_investment9.md">第9章 预测方法</a></li><li><a href="{filename}quantitative_investment10.md">第10章 诊断方法</a></li><li><a href="{filename}quantitative_investment11.md">第11章 时间序列方法</a></li><li><a href="{filename}quantitative_investment12.md">第12章 智能优化方法</a></li></ul></li><li><p>第三篇 实践篇</p><ul><li><a href="{filename}quantitative_investment13.md">第13章 统计套利策略的挖掘与优化</a></li><li><a href="{filename}quantitative_investment14.md">第14章 配对交易策略的挖掘与实现</a></li><li><a href="{filename}quantitative_investment15.md">第15章 数据挖掘在股票程序化交易中的综合应用</a></li><li><a href="{filename}quantitative_investment16.md">第16章 基于数据挖掘技术的量化交易系统</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 目录和总结&lt;/p&gt;
    
    </summary>
    
      <category term="量化交易" scheme="http://holbrook.github.io/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93/"/>
    
    
      <category term="数据分析" scheme="http://holbrook.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="读书笔记" scheme="http://holbrook.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
