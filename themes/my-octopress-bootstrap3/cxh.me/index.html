
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>心内求法</title>
  <meta name="author" content="Holbrook">

  <meta name="description" content="">


  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">


  <link rel="canonical" href="http://cxh.me">
  <link href="/favicon.ico" rel="icon">

<link href="//cdn.bootcss.com/bootstrap/2.3.2/css/bootstrap.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/bootstrap/2.3.2/css/bootstrap-responsive.min.css" rel="stylesheet">

  <link href="/atom.xml" rel="alternate" title="CXH.ME" type="application/atom+xml">
  <link href="/stylesheets/doc.css" media="screen, projection" rel="stylesheet" type="text/css">



</head>



<body   >
  <nav role="navigation"><div class="navbar navbar-inverse navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>

      <a class="brand" href="/">CXH.ME</a>

      <div class="nav-collapse">
        <ul class="nav">
    <li><a href="/blog/archives">Archives</a></li>
    <li class="divider-vertical"></li>
    <li class="dropdown">
<a data-toggle="dropdown" class="dropdown-toggle" href="#">技术相关<b class="caret"></b></a>
<ul class="dropdown-menu">
    <li><a href="/category/ruan-jian-fa-bu">软件发布</a></li>
    <li class="divider"></li>
    <li><a href="/category/c-plus-plus">C++</a></li>
    <li><a href="/category/dot-net">.Net</a></li>
    <li><a href="/category/flex">Flex</a></li>
    <li><a href="/category/ji-chu-li-lun">基础理论</a></li>
    <li><a href="/category/latex">Latex</a></li>
    <li><a href="/category/linux">Linux</a></li>
    <li><a href="/category/mfc">MFC</a></li>
    <li><a href="/category/oceanbase">Oceanbase</a></li>
    <li><a href="/category/fen-bu-shi-xi-tong">分布式系统</a></li>
    <li><a href="/category/php">PHP</a></li>
    <li><a href="/category/java">Java</a></li>
    <li><a href="/category/python">Python</a></li>
    <li><a href="/category/vim">vim</a></li>
    <li><a href="/category/mac">Mac</a></li>
    <li><a href="/category/web">web相关</a></li>
    <li><a href="/category/others">其他</a></li>
    <li class="divider"></li>
    <li><a href="/category/ai-ti-ren-sheng">IT人生</a></li>
</ul>
</li>
<li><a href="/category/shi-qing-bai-tai">世情百态</a></li>
<li><a href="/category/she-ying">摄影</a></li>
<li><a href="/category/sui-bi">随笔</a></li>

</ul>


        <ul class="nav pull-right" data-subscription="rss">
          <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>

        </ul>


          <form class="pull-right navbar-search" action="http://www.google.com/search" method="get">
            <fieldset role="search">
              <input type="hidden" name="q" value="site:cxh.me" />
              <input class="search-query" type="text" name="q" results="0" placeholder="Search"/>
            </fieldset>
          </form>

      </div>
    </div>
  </div>
</div>
</nav>
  <div class="container">
    <div class="row-fluid">
      <div class="span9">



    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2017/04/04/summarize-of-recently-days/">总结下最近的生活</a></h1>


      <p class="meta">














<time datetime="2017-04-04T21:45:00+08:00" pubdate data-updated="true">Apr 4<span>th</span>, 2017</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">房子终于落定了，经历了北京这魔幻的一年，该上车还是上车了。2016-2017发生了太多事情，感觉很多时候是被现实推到了这个状态，很多时候没有什么选择。晚上听高晓松和郁可唯的《一叶知秋》，突然想起大学的那些日夜。时间的流逝，生活的匆忙，偶尔想想曾经的那些简单美好的日子，觉得怅然若失。小时候盼着长大，上学的时候盼着工作，真的工作了，买房了买车了，又感念之前那些一无所有的日子。骑自行车穿梭在校园的时候，从来没想过以后会怎样，自习室老旧的座椅，后花园参天的大树，静谧的日子里，翘课看阳光投过树叶的缝隙落到校园的青石路上。曾经觉得平淡的东西，现在回想起来，似乎再也找不回来了，回想起来仿佛上天的恩赐，封存在记忆的深处，再也不会打开了。</p>

<p class="indent">之前很喜欢收藏这些记忆的东西，老照片，曾经的笔记本，以至上学时候买的那些纪念品，后来发现真的不会再去打开了。记忆，无论甜蜜苦涩，都已经成为记忆，逝去的东西，翻起来都会有种莫名的失落。生活过的略乏味，曾经所期盼的东西，一点点都实现了，没有实现的，似乎也没有那么渴望了，然而听到曾经喜欢的那些音乐，想起校园里那些人那些事，还是会热泪盈眶。生活总把人打磨的没有棱角，让你藏起内心那些柔软的东西，疲于奔命的节奏也让每个人都似乎缺失了那一点文艺。翻翻曾经的博客，上篇文章似乎都是一年前写的，这一年里，大概经历都在工作、买房、买车、忙里忙外上了，依然孤独，依然喜欢孤独。只不过深夜的时候，很少去倾听内心的声音了，大概都湮没在生活的喧嚣里了。</p>

<p class="indent">有时候觉得小城市也有这点好处，屏蔽了其他的纷扰，更容易想明白一些事情，只不过节奏的缓慢让人也更容易陷入伤春悲秋。买了房子之后觉得不管怎么讲，安定感多了很多。房子只是住所，背后有个依靠感觉心理上会好很多，至于其他的投资啊上车啊也都是遥远的事情。买了房子赚不了多少，没买也亏不了多少，北京这个样子，谁都不好说是看涨看跌，长期看，住还是第一需求，虽然远，虽然堵。每过一段时间都会去想生活的意义，尤其完成了一件事情之后，总得有个新的小目标。似乎没那么想创业，也没那么想成家了，离30岁还有半年的时间吧，年龄的压力时有时无，有时候想天高任我飞，有时候也觉得拼不过刚毕业的学生了，再想想35之后40之后中年危机，就觉得现在都开始没有什么安定感了，北京啊北京，永远是个打拼的地方，吞下年轻的骨头突出年老的躯壳，中央给你指了条路去雄安，只是不知道会发展成什么样。</p>

<p class="indent">搬过去之后考虑买个书架，放满我各种小物件，权当是种回忆，再养只猫，下班的生活也能有所慰藉。心态还是要年轻点，既然上天赐你几十年光阴，总要过的充实一点，该体验的都去体验下，该拼搏的都去争取下，才好不后悔啊。follow your heart，年轻嘛，想做什么做什么。</p>

<p class="indent">感慨下人还是不要画标签的好，无论成功失败，无论成家了，有孩子了还是一个人，褪去尘世的装扮，都还是那个白衣飘飘的少年啊。</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/07/04/gcc-printf-format-attribute/">Gcc的格式化字符串检查</a></h1>


      <p class="meta">














<time datetime="2016-07-04T14:53:00+08:00" pubdate data-updated="true">Jul 4<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">之前很好奇为什么printf参数类型跟格式化字符串不匹配的时候为啥有时候可以报错，有时候不能报错。printf的时候如果不匹配经常会看到这种错误：</p>

<pre><code> format ‘%s’ expects type ‘char *’, but argument 12 has type ‘struct S3ListHead * const’
</code></pre>

<p class="indent">很多core是因为这种问题导致的，所以能放到编译期检查的话，确实有助于提高代码质量。后来白哥指点gcc有单独的attribute来指定检查匹配。作为一个编译器，真是良心啊。</p>

<pre><code>format (archetype, string-index, first-to-check)
The format attribute specifies that a function takes printf, scanf, strftime or strfmon style arguments which should be type-checked against a format string. For example, the declaration:
          extern int
          my_printf (void *my_object, const char *my_format, ...)
                __attribute__ ((format (printf, 2, 3)));
</code></pre>

<p class="indent">这样自定义的函数也可以依赖gcc做参数检查了。</p>

<p class="indent">详细的参见<a href="https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Function-Attributes.html" title="Declaring Attributes of Functions">这里</a></p>

<h3>参考文献:</h3>

<blockquote><p>[1] Declaring Attributes of Functions, <a href="https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Function-Attributes.html">https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Function-Attributes.html</a></p></blockquote>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/06/28/search-log-with-timcat/">用timecat来定位日志</a></h1>


      <p class="meta">














<time datetime="2016-06-28T14:33:00+08:00" pubdate data-updated="true">Jun 28<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">介绍一个日志grep的神器。
  做系统开发的人都有从海量日志里面定位bug的经历，大家一般用如下几种方法：</p>

<ol>
<li>head -n xxx|tail -n 1，大概定位位置</li>
<li>直接grep日志来找到对应的行号并用sed cut一段出来。</li>
<li>把日志灌倒hive等ETL工具里面。</li>
</ol>


<p class="indent">但是如上几种方式要么太慢，要么太复杂。最近突然想到有没有二分·grep的工具，搜到如下一个工具timcat:</p>

<p class="indent">安装：</p>

<pre><code>pip install timecat
</code></pre>

<p class="indent">使用：</p>

<pre><code>timecat -d '2016-01-02' -s '20:13:14' -e '20:14:13' LOGFILE1.log LOGFILE2.log ...
timecat -s '2016-01-02 20:13:14' -e '2016-01-02 20:14:13' LOGFILE1.log LOGFILE2.log ...
  For more: timecat -h
</code></pre>

<p class="indent">非常快。</p>

<p class="indent">作者的<a href="http://blog.reetsee.com/archives/502" title="如何对日志文件进行二分查找？开源文件二分查找工具『timecat』介绍">博客</a>讲解如下：</p>

<h3>参考文献:</h3>

<blockquote><p>[1] 如何对日志文件进行二分查找？开源文件二分查找工具『timecat』介绍, <a href="http://blog.reetsee.com/archives/502">http://blog.reetsee.com/archives/502</a></p></blockquote>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/06/20/pypython-is-an-eggache-language/">Python是一门蛋疼的语言</a></h1>


      <p class="meta">














<time datetime="2016-06-20T20:22:00+08:00" pubdate data-updated="true">Jun 20<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">最近在分析一个问题，用python写的测试脚本里面跟store节点通信的时候加了一个starttime和超时，store判断了startime跟当前时间之间是否已经达到超时时间，如果到达就拒绝掉。这个脚本在测试case数少的时候没啥问题，数量大了之后就有超时的问题。开始直接调大了timeout让测试先过去了，最近加了多重timeout判断，不能直接为了测试改参数了，分析一下怀疑timeout只生成了一次，封包代码如下：</p>

<pre><code>def pack_packet(ver, pcode, channel, sess, data):

    fields = (i8(ver), u16(pcode), u16(channel), u64(sess), i64(len(data)), i64(time.time()  * 1000000), u64(0), i64(8000000), u64(0), u64(0))
    header = ''.join(fields)

    crc = u64(crc64(header))
    data_crc = u64(crc64(data))

    return fields + (crc, data, data_crc)

def req_create_replica(replica_id):
    pc = PacketCode
    return pack_packet(0, pc.S3_CREATE_REPLICA, 1, gen_sess_id(), replica_id)
</code></pre>

<p class="indent">python是对静态对象做过优化，相同的静态对象只维护一个，但是这个看着怎么也不是静态对象。后来打日志发现封包的日志都在日志的最前面，才想起来原来这里：</p>

<pre><code>cases_normal_flow = [

('create secondary replica',
 req_create_replica(pack_replica_id(0x01010101, 'cp3p', 5555555)),
 recv_create_replica,
),

('write chunk with 1 record',
 lambda: req_write_chunk(last_created_replica_id(), REPLICA_HEADER, [
         (pack_record_id(0x11111111, 001, 0x55555555), t_object_id, "abcd"), ]),
 (0, [])
),

('read record written in above step',
 lambda: req_read_record(last_created_replica_id(),
                         pack_record_id(0x11111111, 001, 0x55555555)),
 (0, [pack_lstr("abcd")])
)]
</code></pre>

<p class="indent">非lambda表达式的部分已经在cases_normal_flow全局对象定义的时候执行过了，所以要么再发送的时候重新修改时间，要么都换成lambda表达式。python的灵活总让人有种错觉觉得怎么写都是对的。这部分如果在c下面，函数指针和函数执行还是泾渭分明的。当然，人生苦短，要用好python。</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/06/18/ccache-and-cgo/">Ccache和cgo并存的问题</a></h1>


      <p class="meta">














<time datetime="2016-06-18T20:15:00+08:00" pubdate data-updated="true">Jun 18<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent"> ccache是加快编译的神器，有了ccache，忘了distcc。但是发现go和c混编的项目里面如果用了cgo的话，go编译的时候ccache会报错。主要是传给ccache的某些参数ccache不认识。错误如下：</p>

<pre><code>/usr/bin/ccache: invalid option -- 'd'
Usage:
    ccache [options]
    ccache compiler [compiler options]
    compiler [compiler options] (via symbolic link)

Options:
    -c, --cleanup delete old files and recalculate size counters
                          (normally not needed as this is done automatically)
    -C, --clear clear the cache completely
    -F, --max-files=N set maximum number of files in cache to N (use 0 for
                          no limit)
    -M, --max-size=SIZE set maximum size of cache to SIZE (use 0 for no
                          limit; available suffixes: G, M and K; default
                          suffix: G)
    -s, --show-stats show statistics summary
    -z, --zero-stats zero statistics counters

    -h, --help print this help text
    -V, --version print version and copyright information

See also &lt;http://ccache.samba.org&gt;.
dpkg-architecture: warning: Couldn't determine gcc system type, falling back to default (native compilation)
</code></pre>

<p class="indent">之前都是关了ccache，后来想新的版本能不能搞定呢？有人提了Issue但是没看到release上有啥新的fix。直接升了一下版本：</p>

<pre><code>wget https://www.samba.org/ftp/ccache/ccache-3.2.5.tar.bz2
bunzip2 ccache-3.2.5.tar.bz2
tar xvf ccache-3.2.5.tar
cd ccache
./autogen.sh
./configure
make -j 8
yum install asciidoc
make install
</code></pre>

<p class="indent"> 然后export set CC=&lsquo;gcc ccache&#8217;，再重新automake就行了。</p>

<p class="indent"> 但是发现还是一样。后来想可以用shell包一层啊，看<a href="https://bbs.archlinux.org/viewtopic.php?id=204639" title="ccache does not work with nvcc (CUDA)">网上</a>有相应的方案：</p>

<pre><code> #!/bin/bash
 ccache gcc "$@"
</code></pre>

<p class="indent"> 保存这个到path路径下，改名ccached之类，export set CC=ccached，貌似这样ccache不认识的参数就不传递了？反正是ok了，改天研究下。</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/06/17/export-disk-using-nfs/">使用nfs挂载网络磁盘</a></h1>


      <p class="meta">














<time datetime="2016-06-17T11:58:00+08:00" pubdate data-updated="true">Jun 17<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">分布式环境下经常需要到各个节点启动server，常见的方式推的方式，比如scp到各个结点，但是有时候更新的文件少儿需要scp的文件比较多。这时候可以选择nfs挂载的方式把编译好的文件放到网络磁盘上，然后共享到其他的服务器，这样可以按需使用。</p>

<p class="indent">首先配置一下nfs服务器。假设系统都是centos：</p>

<pre><code>yum install -y nfs-utils
yum install -y portmap
rpm -qa | grep nfs
</code></pre>

<p class="indent">事实上看centos6.5以上portmap应该被rpcbind替代了，而已安装nfs-utils的时候应该顺便安装了rpcbind。之后配置一下需要挂载的磁盘：</p>

<pre><code>文件/etc/exports:
/tmp rz*(rw,async) yf*(ro)
</code></pre>

<p class="indent">简单解释一下： /tmp是挂载的目录路径，后面跟权限控制，可以是主机名或者ip，rz*表示rz开头的主机，括号里面是权限。整条语句表示把/tmp目录共享以rw权限和async方式共享给rz开头的机器，同时以ro权限共享给yf开头的机器。其他属性可以参考<a href="http://www.liusuping.com/ubuntu-linux/Redhat-Linux-NFS-setting.html" title="Redhat Linux下NFS的配置及操作">这里</a>:</p>

<p class="indent">之后启动nfs服务：</p>

<pre><code>service nfs start
</code></pre>

<p class="indent">需要挂载机器上同样安装客户端：</p>

<pre><code>yum install -y nfs-utils
</code></pre>

<p class="indent">挂载到指定的目录：</p>

<pre><code>mkdir fs &amp;&amp; mount -t nfs xxx.xxx.xx.xx:/tmp ./fs
</code></pre>

<p class="indent">xxx指定机器名或者ip</p>

<h3>参考文献:</h3>

<blockquote><p>[1] Redhat Linux下NFS的配置及操作, <a href="http://www.liusuping.com/ubuntu-linux/Redhat-Linux-NFS-setting.html">http://www.liusuping.com/ubuntu-linux/Redhat-Linux-NFS-setting.html</a></p></blockquote>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/06/13/safe-spin-lock/">跨线程解锁安全的spinlock</a></h1>


      <p class="meta">














<time datetime="2016-06-13T17:36:00+08:00" pubdate data-updated="true">Jun 13<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">在C语言下面我们可能会写出如下的代码：</p>

<pre><code>static pthread_spinlock_t lock;

__attribute__((constructor))
void lock_constructor () {
    if ( pthread_spin_init ( &amp;lock, 0 ) != 0 ) {
        exit ( 1 );
    }
}

int func(xx) {
  int ret = 0;
  if (xx) {
    ret = ERR1;
    goto exit;
  }
  pthread_spin_lock(&amp;lock);
  if (xx) {
    ret = ERR2;
    goto exit;
  }
exit:
  pthread_spin_unlock(&amp;lock);
  return 0;
}

__attribute__((destructor))
void lock_destructor () {
    if ( pthread_spin_destroy ( &amp;lock ) != 0 ) {
        exit ( 3 );
    }
}
</code></pre>

<p class="indent">这段代码存在下面几个问题：</p>

<pre><code>1. spinlock没有静态初始化函数，需要确保使用前调用了pthread_spin_init.
2. 跳转到exit标记去unlock的时候，并不能保证lock已经被加过锁了。
3. func本身存在潜在的并发问题，一个线程可能跳转到exit去解别的线程加的锁。
</code></pre>

<p class="indent">根据<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_spin_lock.html" title="The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition">文档</a>这几种情况下的行为是未定义的。</p>

<pre><code>  The pthread_spin_lock() function shall lock the spin lock referenced by lock. The calling thread shall acquire the lock if it is not held by another thread. Otherwise, the thread shall spin (that is, shall not return from the pthread_spin_lock() call) until the lock becomes available. The results are undefined if the calling thread holds the lock at the time the call is made. The pthread_spin_trylock() function shall lock the spin lock referenced by lock if it is not held by any thread. Otherwise, the function shall fail.

  The results are undefined if any of these functions is called with an uninitialized spin lock.
</code></pre>

<p class="indent">为了情况1，我们可以考虑通过原子操作实现spin_lock，用一个volatile int64类型的整数来标识当前锁的状态。nginx里面的实现如下：</p>

<pre><code>    /*
     * Copyright (C) Igor Sysoev
     * Copyright (C) Nginx, Inc.
     */


    #include &lt;ngx_config.h&gt;
    #include &lt;ngx_core.h&gt;

    //Function: to achieve spin atomic operation lock method based on ngx_spinlock
    //Parameter interpretation:
    //lock: Lock the atomic variable expression
    //value: Flag, whether the lock is a process
    //spin: In a multi processor system, when the ngx_spinlock method did not get the lock, the current process in a scheduling kernel in the waiting for the other processors to release the lock time
    void
    ngx_spinlock(ngx_atomic_t *lock, ngx_atomic_int_t value, ngx_uint_t spin)
    {

    #if (NGX_HAVE_ATOMIC_OPS)//Support atomic operations

        ngx_uint_t  i, n;

        //Has been in circulation, until the lock is acquired
        for ( ;; ) {

            //Lock 0 said no other process holding the lock, then the lock value indicates the current process holding the lock is set to value parameters
            if (*lock == 0 &amp;&amp; ngx_atomic_cmp_set(lock, 0, value)) {
                return;
            }

            //If it is a multi processor system
            if (ngx_ncpu &gt; 1) {
                for (n = 1; n &lt;spin; n &lt;&lt;= 1) {
                    //With the increasing number of the actual to wait, inspection interval and lock more
                    for (i = 0; i &lt;n; i++) {
                        ngx_cpu_pause();//Tell CPU now in the spin lock wait state
                    }

                    //Check the lock is released
                    if (*lock == 0 &amp;&amp; ngx_atomic_cmp_set(lock, 0, value)) {
                        return;
                    }
                }
            }

            //The current process for the processor, but still in the executable state
            ngx_sched_yield();
        }

    #else

    #if (NGX_THREADS)

    #error ngx_spinlock() or ngx_atomic_cmp_set() are not defined !

    #endif

    #endif

    }
</code></pre>

<p class="indent">简单解释几个关键点：</p>

<ol>
<li> ngx_atomic_cmp_set等是nginx封装的原子操作，可以从字面意思理解。能直接对应到gcc支持的一些原子操作。</li>
<li> ngx_cpu_pause是不切换cpu上下文的让cpu让出时间片的操作，可对应到后文的<strong>asm</strong>(&ldquo;.byte 0xf3, 0x90&rdquo;);</li>
<li> ngx_sched_yield 暂时挂起上下文，让cpu调度其他任务。</li>
</ol>


<p class="indent">nginx的实现解决了静态初始化的问题，但是解决不了上述问题2和3。为此我们可以考虑在表征spinlock状态的整形变量中加入线程id，来区分操作者是否是锁持有者。参考实现如下：</p>

<pre><code>typedef volatile int64_t Atomic;

#define _spin_unlock_safe   _unlock_safe

typedef struct {
 union {
  struct {
    int32_t tid;
    int32_t atomic32;
  };
  volatile int64_t atomic;
 };
} CACHE_ALIGNED SpinLock;

static __inline__ int64_t _get_tid() {
  static __thread int64_t tid = -1;
  if _unlikely(tid == -1) {
    tid = (int64_t)(syscall(__NR_gettid));
  }
  return tid;
}

static __inline__ int _try_lock_safe(SpinLock *lock) {
  SpinLock lock_val = };
  return lock-&gt;atomic == 0 &amp;&amp; _atomic_cmp_set(&amp;lock-&gt;atomic, 0, lock_val.atomic);
}

static __inline__ int _unlock_safe(SpinLock *lock) {
  SpinLock lock_val = };
  return _atomic_cmp_set(&amp;lock-&gt;atomic, lock_val.atomic, 0);
}

static __inline__ void _spin_lock_safe(SpinLock *lock) {
  int i, n;
  SpinLock lock_val = };
  for (; ;) {
    if (lock-&gt;atomic == 0 &amp;&amp; _atomic_cmp_set(&amp;lock-&gt;atomic, 0, lock_val.atomic)) {
      return;
    }

    for (n = 1; n &lt; 1024; n &lt;&lt;= 1) {

      for (i = 0; i &lt; n; i++) {
        __asm__(".byte 0xf3, 0x90");
      }

      if (lock-&gt;atomic == 0 &amp;&amp; _atomic_cmp_set(&amp;lock-&gt;atomic, 0, lock_val.atomic)) {
        return;
      }
    }

    sched_yield();
  }
}

static __inline__ void _spin_lock(Atomic *lock) {
  int i, n;
  for (; ;) {
    if (*lock == 0 &amp;&amp; _atomic_cmp_set(lock, 0, 1)) {
      return;
    }

    for (n = 1; n &lt; 1024; n &lt;&lt;= 1) {

      for (i = 0; i &lt; n; i++) {
        __asm__(".byte 0xf3, 0x90");
      }

      if (*lock == 0 &amp;&amp; _atomic_cmp_set(lock, 0, 1)) {
        return;
      }
    }

    sched_yield();
  }
}
</code></pre>

<p class="indent">简单解释几个问题：</p>

<ol>
<li> <strong>asm</strong>(&ldquo;.byte 0xf3, 0x90&rdquo;);是intel的一条指令，实际上就是上面的ngx_cpu_pause</li>
<li> sched_yield实现等同于ngx_sched_yield</li>
<li> 用两个int32拼成了一个64位整数，考虑截取了tid有风险，后期可以优化成只用一位表示加锁状态，剩下63位依然给tid用。</li>
</ol>


<h3>参考文献:</h3>

<blockquote><p>[1] The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_spin_lock.html">http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_spin_lock.html</a></p></blockquote>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/06/06/glibc-no-symbol-problem/">有关coredump没有符号的问题</a></h1>


      <p class="meta">














<time datetime="2016-06-06T15:02:00+08:00" pubdate data-updated="true">Jun 6<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">线上server core掉了，看dmesg能看到core的日志，</p>

<pre><code>s3store[16586]: segfault at 2a28000 ip 00007fda20543b58 sp 00007fd9e9894128 error 4 in libc-2.12.so[7fda204ba000+18a000]
</code></pre>

<p class="indent">但是/proc/sys/kernel/core_pattern指向的位置并没有core文件，改一下core_pattern再跑应该能core出来，不过并不是稳定复现的。所以只能先凭这条日志来分析了。从core的位置看，大概率应该是malloc里面的问题。用</p>

<pre><code>addr2line -e xxx  00007fda20543b58
</code></pre>

<p class="indent">看到的结果是??:0。怀疑是glibc没有调试信息。看一下系统的glibc版本：</p>

<pre><code>rpm -qa |grep glibc
glibc-common-2.12-1.166.el6_7.7.x86_64
glibc-static-2.12-1.166.el6_7.7.x86_64
glibc-2.12-1.166.el6_7.7.x86_64
glibc-devel-2.12-1.166.el6_7.7.x86_64
glibc-debuginfo-common-2.12-1.166.el6_7.7.x86_64
glibc-headers-2.12-1.166.el6_7.7.x86_64
glibc-debuginfo-2.12-1.166.el6_7.7.x86_64
</code></pre>

<p class="indent">去centos网站上下对应版本的glibc debuginfo并安装</p>

<pre><code>http://debuginfo.centos.org/6/x86_64/
wget http://debuginfo.centos.org/6/x86_64/glibc-debuginfo-2.12-1.166.el6_7.7.x86_64.rpm
wget http://debuginfo.centos.org/6/x86_64/glibc-debuginfo-common-2.12-1.166.el6_7.7.x86_64.rpm
rpm -ivh glibc-debuginfo-common-2.12-1.166.el6_7.7.x86_64.rpm
rpm -ivh  glibc-debuginfo-2.12-1.166.el6_7.7.x86_64.rpm
</code></pre>

<p class="indent">之后继续addr2line -e xxx 00007fda20543b58还是没有&hellip;</p>

<p class="indent">我擦嘞。改天继续。</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/05/26/union-struct-initialize/">Union和struct相互嵌套时的初始化</a></h1>


      <p class="meta">














<time datetime="2016-05-26T11:01:00+08:00" pubdate data-updated="true">May 26<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><pre><code>typedef union {
volatile int64_t atomic;
    struct{
      int32_t pid;
      int32_t atomic32;
    };
} S3Atomic;

int main(int argc, const char *argv[]) {
    S3Atomic atomic = ;
    printf("%x\n", atomic.pid);
    printf("%x\n", atomic.atomic32);
    printf("%lx\n", atomic.atomic);
    return 0;
}
</code></pre>

<p><a href="http://smilejay.com/2011/12/gcc_union_in_struct/" title="联合体(UNION)在结构体(STRUCT)中的初始化（GCC语法）">参考如下代码</a></p>

<pre><code>/*
 * This sample shows definition and initiation of a struct and a union in a struct.
 * using GCC to compile this C file
 * Author: Jay Ren
*/

#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
    struct my_struct1 {
        int num1;
        union {
            int num2;
            char ch;
        };
    };

    struct my_struct1 my_st1 = {
        .num1 = 111,
        /* the following commented line will cause a syntax error. */
        /* .num2 = 123456,*/
    };

    /* num2 or ch in the union of the struct can't be initiated before. */
    my_st1.num2 = 123456;

    printf("my_st1.num1 = %d\n", my_st1.num1);
    printf("my_st1.num2 = %d\n", my_st1.num2);

    struct my_struct2 {
        int num1;
        union my_union {
            int num2;
            char ch;
        } my_u;
    };

    struct my_struct2 my_st2 = {
        .num1 = 222,
        /*  the following line for initiating num2 works fine. */
        .my_u.num2 = 123456,
    };

    printf("my_st2.num1 = %d\n", my_st2.num1);
    printf("my_st2.num2 = %d\n", my_st2.my_u.num2);

    return 0;
}
</code></pre>

<h3>参考文献:</h3>

<blockquote><p>[1] 联合体(UNION)在结构体(STRUCT)中的初始化（GCC语法）, <a href="http://smilejay.com/2011/12/gcc_union_in_struct/">http://smilejay.com/2011/12/gcc_union_in_struct/</a></p></blockquote>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/05/18/loglogrotate-version-problem/">Logrotate版本问题</a></h1>


      <p class="meta">














<time datetime="2016-05-18T16:02:00+08:00" pubdate data-updated="true">May 18<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">线上运维过程中切日志用了logrotate，但无奈日志打的太多，一天的日志几十G难以分析，遂决定改成每小时切分一次日志。从logrotate的说明看有hourly的支持，但是直接把daily改成hourly之后启动报错：</p>

<pre><code>unknown option 'hourly'
</code></pre>

<p class="indent">感觉是logrotate 3.8.7的版本不支持hourly语法</p>

<p class="indent">rpm安装logrotate高版本的包提示缺少fillup和其他的依赖，同时glibc的版本也要求高版本。于是下载了logrotate的源码安装，以最新版本3.9.2为例</p>

<pre><code>./autogen.sh
./configure
</code></pre>

<p class="indent">提示缺少libpopt头文件，下载了libpopt 1.5的源码安装，提示libtool版本不对。我擦嘞。</p>

<p class="indent">后来突然想到libpopt是debian下的命名，试一下centos下</p>

<pre><code>yum install popt-devel -y
</code></pre>

<p class="indent">搞定。于是继续源码安装，直接用logrotate的官网版本好了。</p>

<pre><code>yum install popt-devel -y
wget https://fedorahosted.org/releases/l/o/logrotate/logrotate-3.8.6.tar.gz
tar zxvf  logrotate-3.8.6.tar.gz
cd logrotate-3.8.6 &amp;&amp; make &amp;&amp; make install
</code></pre>

<p class="indent">这个版本是可以稳定使用的。中间试了几个别的版本，3.8.3还是不支持hourly语法，3.8.5支持了语法，但是测试的时候</p>

<pre><code>logrotate -d /etc/logrotate.conf
</code></pre>

<p class="indent">有core，跟进源码去感觉是依赖bug，换到3.8.6终于ok了&hellip;回去看作者更新日志：</p>

<pre><code>3.8.4 -&gt; 3.8.5
     - Improved rotation during daylight saving time and between timezone
       changes.
     - Fixed ACL setting problem caused by ext3 erroneously reporting ENOSYS
       instead of ENOSUP.
     - Do not continue with rotation if state file is corrupted.
     - Make logrotate.status creation atomic.
     - Allow "hourly" rotation. See manpage for more information.
     - Use "/bin/echo" in tests. Fixes tests execution in Dash.
     - Do no try to parse config files bigger than 16MB.
     - Improved manpage consistency and formatting.
     - Fix race condition between acl_set_fd() and fchmod().
</code></pre>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/05/15/lost-in-time/">迷失在时间里</a></h1>


      <p class="meta">














<time datetime="2016-05-15T23:34:00+08:00" pubdate data-updated="true">May 15<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent"> 好久没写写自己心里的感受了。大概自从毕业工作之后，每天忙很多的事情，就不再有心情去体会一些事情。习惯了忙碌于工作，在这个城市的街头、地铁和公交站穿行，每天想的是五环的房价、今天有没有雾霾和路上堵不堵，只有夜深人静的时候才会想起以前的日子。</p>

<p class="indent"> 想起北航的参天大树，想起以前的同学，想起清华的荷塘，想起校园里美好的日子和可爱的女生，想起晚上安静的校园和校园外的车水马龙。大学的生活确实是人生最美好的几年，让你无论什么时候回想起来都觉得心底柔软、岁月静好。</p>

<p class="indent"> 有时候觉得自己迷失在时间里了。每天早晨醒来，想的都是匆匆逝去的时间和忙不完的事情。停下脚步，听见风穿过的声音，才觉得时间的洪流里面，也有这些许的温存，有难得的避风港，让灵魂停下来歇息一下。哎，我曾经是多么感性的一个人啊&hellip;</p>

<p class="indent"> 物是人非。尽量不去想这些事情。每每回忆以前都觉得会触动心里的痛点，看时光匆匆流去，那些逝去的画面，变得越发模糊，而又无可奈何。于是习惯了让工作占据思想，理性太多而湮没感性，这如何又不是一种躯壳。生活节奏已经进入快车道，每每停下来的时候都会觉得不安，这偶然的感性就变得异常奢侈。</p>

<p class="indent"> 入夜。这座熟悉而陌生的城市，又一次慢慢进入梦乡。同一面蓝天下的人啊，有人睡去，有人醒着，有人睡不着。窗外灯火阑珊，寂寞的人，愿你在时光中找到温暖。</p>

<p class="indent"> <img class="img-polaroid center" src="/images/2016/campus.jpg"></p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/05/15/dirname-and-basename-cautions/">Dirname和basename的一些细节</a></h1>


      <p class="meta">














<time datetime="2016-05-15T14:42:00+08:00" pubdate data-updated="true">May 15<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">作为获取文件名和文件路径的函数，dirname和basename的签名是：</p>

<pre><code>#include &lt;libgen.h&gt;

char *dirname(char *path);

char *basename(char *path);
</code></pre>

<p class="indent">之前没注意的地方是这个函数的输入输出都不是const的，也就意味着这个函数调用过程可能会修改char*指向的string内容。所以直接输出一个不可变字符串是不行的，同理，也要考虑这个非const函数会破坏入参。也就是：</p>

<pre><code>char *str = "/abc/def";
printf("%s\n", dirname(str));
</code></pre>

<p class="indent">会core掉。而</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;libgen.h&gt;
int main(int argc, const char *argv[]) {
  char str[] = "/abc/def";
  printf("%s\n", dirname(str));
  printf("%s\n", basename(str));
  printf("%s\n", str);
  return 0;
}
</code></pre>

<p class="indent">输出结果是：</p>

<pre><code>/abc
abc
/abc
</code></pre>

<p class="indent">还有一个更有意思的问题&hellip;.如果对同一个path先后调用dirname和basename，那么返回的只有一个是对的&hellip;.因为源已经被修改了。反过来可以。</p>

<p class="indent">path在执行过程中被修改了。C系的函数很多面临这个问题，如果不这么做的话要申请一块额外的内存，然后返回，而释放这块内存的工作得调用方完成，这种情况下，内存泄露的可能性很大，所以很多c库函数的选择是用全局变量（getopt等)或者修改入参（basename等）。</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/04/03/summarize-isolation-lock/">数据库锁和隔离级别的总结</a></h1>


      <p class="meta">














<time datetime="2016-04-03T19:34:00+08:00" pubdate data-updated="true">Apr 3<span>rd</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">最近在琢磨MVCC和悲观乐观锁的问题，感觉有些以前学习的点没有串联起来，主要是隔离级别和锁相关的，这里总结思考一下：</p>

<ol>
<li><p> 两阶段锁解决了什么问题</p>

<p>两阶段锁主要解决事务调度的可串行化，保证了调度是正确的。一个简单的例子参考<a href="http://baike.baidu.com/view/3798716.htm" title="两阶段封锁">度娘</a>这里。</p></li>
<li><p> 实现两阶段锁对应了什么隔离级别。</p>

<p>两阶段锁保证了基本的隔离级别正确性，RC之上的隔离级别（包含RC）都需要至少保证两阶段锁。一个例外是如果where条件不走索引的话，是可能全表加锁的，这种情况下mysql为了性能提前解锁了不满足条件的行，参见<a href="http://hedengcheng.com/?p=771#_Toc374698312" title="MySQL 加锁处理分析">这里</a>。</p></li>
<li><p> 各个隔离级别对应的加锁策略。</p>

<p>这个比较简单了：</p>

<ul>
<li>RU：读加S锁，写加X锁，完成即可释放。</li>
<li>RC：读加S锁，写加X锁，读锁完成可释放，写锁一直到事务完成再释放。</li>
<li>RR：读加S锁，写加X锁，读写锁都一直到事务完成再释放。</li>
<li>SE: RR基础上再加范围锁。</li>
</ul>
</li>
<li><p> select如何防止丢失更新。</p>

<p>按照<a href="http://hedengcheng.com/?p=771#_Toc374698312" title="MySQL 加锁处理分析">何登成</a>博客里面的定义，可以区分MVCC下两种读。</p>

<p>快照读</p>

<ul>
<li>select * from table where ?;</li>
</ul>


<p>当前读。</p>

<ul>
<li>select * from table where ? lock in share mode;</li>
<li>select * from table where ? for update;</li>
<li>insert into table values (…);</li>
<li>update table set ? where ?;</li>
<li>delete from table where ?;</li>
</ul>


<p>快照读级别下，写事务可能丢失更新，因为select并不阻塞写，两个读写事务可能基于同一个快照点。当前读级别下，写阻塞读，所以涉及同一行的读写事务一定是串行的。不会丢失更新。</p>

<p>基于乐观锁的方式下，也不会丢失更新，因为检查到更新可能被覆盖的操作都会回滚（打回重试）了。</p></li>
<li><p> MVCC和锁（悲观乐观）的实现方式下，隔离级别是怎么实现的？</p>

<p>MVCC主要针对冲突数据的处理，乐观锁、悲观锁决定了最终原子的更新一行的方式。</p>

<p>MVCC加乐观锁的方式基本思路如下：</p>

<blockquote><p>定义一个keyValueSet，Conditional Update在此基础上加上了一组更新条件conditionSet { … data[keyx]=valuex, … }，即只有在D满足更新条件的情况下才将数据更新为keyValueSet’；否则，返回错误信息。<a href="http://coolshell.cn/articles/6790.html" title="多版本并发控制(MVCC)在分布式系统中的应用">引用</a></p></blockquote>

<p>MVCC加悲观锁主要是提供了不加锁的读。按<a href="http://hedengcheng.com/?p=771#_Toc374698312" title="MySQL 加锁处理分析">何登成</a>的文章里看，就是快照读+当前读。快照读级别下，直接按照版本读就行，当前读级别下，如果有锁冲突还是要加锁。</p>

<p>在ob里的实现上看比较明显，行的修改增量组织为一棵B树，历史版本表现为B树叶子节点上挂的链表。链表的按照版本号串接起所有历史版本，全局Publish version决定了当前可见的最新版本。</p>

<p>在快照读级别下，select不需要加锁，只需要每次按照publish version去链表遍历，找到可见的结果并返回。如果不修改transaction consistency set的情况下，这种读取可能导致两次读结果不一致，不满足RR或者SI(Snapshot Isolation)。OB0.5增加了一个readonly snapshot的级别，可以提供对一个快照的只读操作，保证了多次读取的一致，但是没有snapshot级别不加锁的读写事务（快照写），毕竟基于一个旧的快照做写操作可能使新的提交丢失。这里要么类似乐观锁验证一下版本，要么加锁来延迟读写。</p>

<p>当前读级别下，select也要加锁直到事务结束释放，跟mysql的实现一致。</p>

<p>总结来讲，如果把当前读看成写事务的话，那么ob事实上是读操作只看版本号，写操作只看锁。如果只考虑当前读和写操作的话，那么相当于有冲突的时候读锁延迟了写操作，写锁延迟了读操作，保证了调度的串行。这种情况下，多次读取的结果是一致的。</p></li>
<li><p> select for update在mvcc下如何实现。</p>

<p>道理是一样的，跟mvcc没什么关系，select for update实际上相当于写事务（select的时候加写锁，直到事务结束再释放，update操作本身也是一样的过程，先检索符合条件的记录加锁，再修改并提交，这样才能保证是原子的）</p></li>
<li><p> 分布式环境下的快照读</p>

<p>单点的快照相对来讲比较容易，因为每次可以取一下publish version，来决定什么是可以读取的，但是分布式环境下，每个点读取的时候不能总去看全局publish version(似乎也可以)， 这样本地读取的时候可能由于时间偏移出现全局本地开启事务的时间戳大于全局publish version的问题，</p></li>
</ol>

</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/04/02/cgo-practice/">Cgo实践</a></h1>


      <p class="meta">














<time datetime="2016-04-02T16:56:00+08:00" pubdate data-updated="true">Apr 2<span>nd</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">工作里遇到一个问题，想把mysql的crc直接封装一下让go来调用，因为查表的crc计算性能实在是不快，对我们这种文件系统的大报文计算来看，crc容易变成瓶颈。大概性能对比如下：</p>

<pre><code>两线程crc32查表 O2优化
time_elapsed:471.474976s
total_size_m : 200000.000000M
crc rate : 424.200684m/s


两线程crc64指令 O2优化
time_elapsed:24.877853s
total_size_m : 200000.000000M
crc rate : 8039.278809m/s
</code></pre>

<p class="indent">c这一端的计算比较容易，go的crc默认是查表， 所以存在不兼容的问题。出于兼容和性能考虑，用cgo封装一下。</p>

<p class="indent">首先在c语言下把crc打包成lib库，考虑go的移植，直接用静态库比较好。go这边调用如下：</p>

<pre><code>package s3crc

import "unsafe"

// #include &lt;stdlib.h&gt;
// #cgo CFLAGS: -I../../../../src/lib
// #cgo LDFLAGS: -L../../../../src/lib -lcrc
// #include "s3_crc64.h"
import "C"

func s3_crc64(buf string, len int64) uint64 {
    cbuf := C.CString(buf)
    defer C.free(unsafe.Pointer(cbuf))
    return uint64(C.s3_crc64(unsafe.Pointer(cbuf), C.int64_t(len)))
}
</code></pre>

<p class="indent">遇到的坑主要有：</p>

<ol>
<li> cgo不支持ccache，所以这个比较扯。习惯使用ccache的同学（好样的）建议export CC=gcc</li>
<li> 所有类型都需要做转换。go的类型对应到c的类型之后，都在C命名空间下。</li>
<li> 静态库路径需要指明，go的buffer映射到c下面之后，需要考虑释放的问题。参见<a href="https://golang.org/cmd/cgo/" title="Command cgo">文献</a></li>
</ol>

</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/03/28/thinkthinking-about-paxos-and-raft/">关于Paxos和Raft的一些思考</a></h1>


      <p class="meta">














<time datetime="2016-03-28T23:33:00+08:00" pubdate data-updated="true">Mar 28<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent"> 最近在总结一些协议这么设计的原因，比较杂，纯做记录：</p>

<ol>
<li><p>选主过程相当于Paxos的prepare过程：</p>

<p>选出的Leader得到了多数派的同意，相当于Paxos一阶段完成，由于当前Term下投过票的Server保证不再接受小于等于当前Term的，所以保证了选主最终只能选出一个。</p>

<p>不同于Paxos的地方在于这一轮Term下，follower除非Lease过期，否则不会发起新的选主，也就是发起Epoc更大的提案。Raft可以认为MultiPaxos的一种应用，MultiPaxos可以认为是合并了Prepare阶段的SingleDegreePaxos.</p></li>
<li><p>raft读一致性和选主timeout</p>

<p>raft协议本身由于主只是续约了follower的lease，所以正常情况下follower不会在lease过期前发起新的选主，但是master网络分区情况下，master本身不维护自己的lease，follower lease过期会发起新的选主从而产生新的主。这时候旧主的写一定不能成功，但是旧主的读不受影响。</p>

<p>以前在ob的时候阳老师设计的选主协议里面通过主lease来解决了这个问题，只是当时没体会到原因在这里。协议要求补充限制：主在自己的lease过期后放弃主的身份，主维持心跳的过程中续约follower的lease，根据rpc的返回，只有收到多数派的回应并且term没有更大的才续约自己的lease。新启动的server在follower状态至少等一个lease周期才发起选主，来让可能的旧主过期。</p></li>
<li><p>paxos是两阶段提交的一种场景。</p>

<p>两阶段提交的一阶段也是获得所有参与者的同意。只不过是所有而不是多数派，一阶段通过之后，相当于决议已经形成，所以后一阶段不会产生新的决议。2阶段可以完全异步来做，如果2阶段失败，不影响形成的决议。这意味着两阶段提交是非抢占式的。</p></li>
</ol>

</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/03/28/notes-on-liupeng-report/">刘鹏《移动时代的营销与变现》笔记</a></h1>


      <p class="meta">














<time datetime="2016-03-28T23:13:00+08:00" pubdate data-updated="true">Mar 28<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">上次见刘鹏老师可能还是搜狐实习的时候，后来刘鹏走了，峰扬走了，整个团队改做推荐系统，最后又回到效果广告，算是绕了一个圈吧。买了本计算广告，更多的是给自己一个念想，念念不忘必有回响么。</p>

<p class="indent">主要记录几个知识点或者观点：</p>

<ol>
<li><p> 竞价的历史性作用、gd广告和竞价广告的诞生原因</p>

<p>保量（guarantee delivery）广告相对于品牌广告（CPT），主要解决了流量浪费的问题，CPM的售卖方式相对增加了广告流量的利用率（比如按照性别的售卖，大致可以增加20-25%的收益）。然而保量广告相对来讲对流量的利用并不极致，大部分gd系统都面临超卖或者保守售卖的问题，可能会导致补量或者浪费，在线流量分配和优化也是个比较复杂的问题。所以才有了竞价广告，根据<a href="https://www.zhihu.com/question/19804990" title="怎样向非专业人士专业地解释「纳什均衡」？">Nash均衡</a>，广告价格是出价方博弈的结果。这样就可以让广告效益最大化，区分优质流量，同时长尾的流量也有变现的机会。</p>

<p>当然也就引入了程序化交易。程序化交易是工业化的结果，但是对于广告来讲，良莠不齐的广告对于场景融入是非常不利的。程序化交易在移动时代带来了更不好的用户体验。</p></li>
<li><p> 搜索广告的场景和精妙之处</p>

<p>搜索广告实现了两点最精巧的地方：精确判断用户意图，跟媒体内容完美融入，所以历来是兵家必争之地。</p></li>
<li><p> 移动广告、gps定位、地理位置</p>

<p>移动时代，广告不能照搬PC时代的经验。移动设备屏幕上广告的体验是很差的。移动时代对于用户意图的判断实际上是更精准了，比如可以通过GPS等判断用户所处的位置，推送更符合场景的广告。但是广告体验就更加困难了，这是有利有弊的地方。</p></li>
<li><p> O2O是潜在的广告市场</p>

<p>O2O商家是之前几乎不可能成为广告主的一个群体。O2O广告有相当的地域要求，所以对Targeting的要求更高，相对PC时代，移动时代才是O2O广告能发力的地方。智能手机的普及提供了更精准的Targeting，使这部分人群有可能成为潜在广告主。</p></li>
</ol>


<h3>Bibliography:</h3>

<p class="indent">[1] 怎样向非专业人士专业地解释「纳什均衡」？, <a href="https://www.zhihu.com/question/19804990">https://www.zhihu.com/question/19804990</a></p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/03/25/netlib-bug-analysis/">记录一个网络库设计的bug</a></h1>


      <p class="meta">














<time datetime="2016-03-25T00:14:00+08:00" pubdate data-updated="true">Mar 25<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent"> 今天遇到一个设计上没考虑好的问题，记录一下。</p>

<p class="indent"> 之前Libeasy的逻辑如果一个连接上有超时的报文的话，整个连接会destroy掉。考虑网络拥塞的情况，如果AB两个报文同时在等待发送，A报文先进入发送队列（链表，非TCP发送buffer），B后进入，而A超时时间长，B立即超时，那么清理掉B的待发送报文的时候，如果destroy掉连接，那么本来可以发送出去的A报文就被强制失败了。</p>

<p class="indent"> 考虑这种情况做了一点修改，让超时的报文被清理掉的时候不会destroy连接。这样编码的时候需要指定一个报文被编码出来的buffer是属于哪个会话（session）的，同时记录一下每个session对应的最后一个buffer位置。清理的时候可以从上述位置回溯到不属于当前session的buffer或者到头部为止。看似没啥问题。今天发现了如下的bug：</p>

<p class="indent"> 考虑如果一个会话编码的多个buffer（或者一个buffer）被部分发送完毕（write返回大小为准），这时候会话超时，这个会话所属的所有编码过的buffer都被干掉，但是连接并没有被destroy，之后的报文继续发送的话，客户端实际上收到了不完整的报文，相当于之后的TCP流都错位了。这种情况下，destroy连接是明显更安全的做法。</p>

<p class="indent"> 所以还是要考虑周全啊。</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/03/18/farwell-yanpo/">关于最近的一些事情</a></h1>


      <p class="meta">














<time datetime="2016-03-18T23:47:00+08:00" pubdate data-updated="true">Mar 18<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent"> 最近其实是乏善可陈的，项目差不多写完，修修补补，提升下性能。其他的事情诸多不顺，看房价蹭蹭的涨，看工资慢慢的爬，感情纠结一团，其他的么，牙疼，估计牙周炎犯了。</p>

<p class="indent"> 然后今天炎泼说要走了，陈闯二话没说也跟着走了，先知先觉的后知后觉的都有各自的想法，只是我比较懵逼，可能最近事情多了，精力都不在这上面。每个人有自己的选择，目前看互联网差不多进入稳定期了，风口还有，但是能飞起来的猪不多了，剩下的人，要么在大公司朝九晚五，要么在创业公司等期权等上市，少数人还追求着理想，不过最后如果没有回到前面两个状态的话，一般是创业去了。</p>

<p class="indent"> 工作几年觉得介于目的性明确和不明确之间吧。做技术的明显分了两派，以KPI为核心的和以兴趣为核心的，很多时候这两个不是不兼容的。目的明确的，一切跟个人发展不相关的都推掉，目的不明确的，还是选择follow heart多一点。没有褒贬，个人选择而已。最好是大方向下，找点自己喜欢做的，否则工作容易无趣啊。不过这种坑也似乎不好找，当然不排除有人兴趣特别，比如我就是向往资产阶级腐朽堕落的生活方式&hellip;</p>

<p class="indent"> 博客好久不写了。感觉技术文章吧，一旦开头容易虎头蛇尾，扯扯淡吧，微博微信朋友圈足够了。无聊的时候，也就是刷刷知乎找朋友扯扯淡，看看有没有新梗，翻墙看看。最近整个社会都压抑吧，连门缝里塞小纸片的都少了，可见人民群众都进入到了一种就这样吧还能咋滴的状态里。</p>

<p class="indent"> 所以我还是一直觉得要找到一点精神的寄托，哪怕是打游戏呢（没鄙视的意思打游戏挺好）。最近听许巍的新歌《生活不止眼前的苟且》，觉得似乎又回到校园了，回到北航的主楼，回到绿园的树荫和荷塘，想起陈旧的宿舍楼里阳光洒在斑驳的墙面，想起清华园的午后，想起月下的荷塘，想起东门外五道口的火车道&hellip;</p>

<pre><code>    生活不止眼前的苟且
    还有诗和远方的田野
    你赤手空拳来到人世间
    为找到那片海不顾一切
</code></pre>

<p class="indent"> 所以我这么感性的人是不是应该去搞音乐&hellip;毕竟钢琴比键盘也就是多了几十个键而已，用惯了Emacs的话，和弦弹起来也没什么按不过来的。</p>

<p class="indent"> 都是幻觉，都是幻觉&hellip;</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/03/18/go-xml-escape/">Go生成xml的时候特殊字符转义的问题</a></h1>


      <p class="meta">














<time datetime="2016-03-18T17:43:00+08:00" pubdate data-updated="true">Mar 18<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">最近在做http返回的时候发现go的xml生成（marshal）会把引号转义，如下：</p>

<pre><code>    &lt;?xml version="1.0" encoding="UTF-8"?&gt;

    &lt;Part&gt;
      &lt;PartNumber&gt;1&lt;/PartNumber&gt;
      &lt;LastModified&gt;2016-03-18T08:24:25.000Z&lt;/LastModified&gt;
      &lt;ETag&gt;&amp;#34;0c78aef83f66abc1fa1e8477f296d394&amp;#34;&lt;/ETag&gt;
      &lt;Size&gt;12121&lt;/Size&gt;
    &lt;/Part&gt;
</code></pre>

<p class="indent">看了下源码，marshal函数的实现就会默认转义。这样就只能加一个Type，不直接用string，然后定义这个Type的marshl函数。上网搜了一下发现可以找个方法绕过去：struct的修饰可以指明当前的struct field不做转义，直接输出。</p>

<pre><code>    type Part struct {
         XMLName      xml.Name `xml:"Part"`
         PartNumber   int
         LastModified string
         ETag         string `xml:",innerxml"`
         Size         int64
    }
</code></pre>

<p class="indent">这样可以直接在序列化的时候传自己拼成的ETag值。比如：</p>

<pre><code>     Part{PartNumber: 1,
         LastModified: S3TimeFormat(GetCurrentTime()),
         ETag:         `&lt;ETag&gt;"acbd18db4cc2f85cedef654fccc4a4d8"&lt;/ETag&gt;`,
         Size:         12121}
</code></pre>

<p class="indent">输出结果满足要求：</p>

<pre><code>    &lt;?xml version="1.0" encoding="UTF-8"?&gt;

    &lt;Part&gt;
      &lt;PartNumber&gt;1&lt;/PartNumber&gt;
      &lt;LastModified&gt;2016-03-18T08:32:39.000Z&lt;/LastModified&gt;&lt;ETag&gt;"acbd18db4cc2f85cedef654fccc4a4d8"&lt;/ETag&gt;
      &lt;Size&gt;12121&lt;/Size&gt;
    &lt;/Part&gt;
</code></pre>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2016/03/06/vim-comple-error-with-pyunicodeucs4-asencodedstring/">vim编译错误：PyUnicodeUCS4_AsEncodedString</a></h1>


      <p class="meta">














<time datetime="2016-03-06T14:45:00+08:00" pubdate data-updated="true">Mar 6<span>th</span>, 2016</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">换了个ubuntu的环境想编译一下vim，为了防止不兼容手动编译了python2.7，之后把改过的vim源码放上去编译发现有问题：</p>

<pre><code>undefined symbol: PyUnicodeUCS4_AsEncodedString
</code></pre>

<p class="indent">于是换回标准的vim源码还是一样的问题，我擦嘞。上网搜一下说Python模式是UnicodeUCS2的支持，从源码里面直接grep一下这个函数发现是有的：</p>

<pre><code>Include/unicodeobject.h:# define PyUnicode_AsEncodedString PyUnicodeUCS4_AsEncodedString
</code></pre>

<p class="indent">那只可能是没有开启编译选项了，./configure &mdash;help发现有如下一项：</p>

<pre><code>  --enable-unicode[=ucs[24]]
                      Enable Unicode strings (default is ucs2)
</code></pre>

<p class="indent">configure到ucs4重新编译python2.7，完美。没毛病。</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2015/12/19/libev-source-analysis/">Libev源码分析</a></h1>


      <p class="meta">














<time datetime="2015-12-19T16:29:00+08:00" pubdate data-updated="true">Dec 19<span>th</span>, 2015</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">本文源码以libev4.20为准，其他版本大同小异。</p>

<p class="indent">libev是广泛使用的事件库，是一个功能强大的reactor，可以把Timer、IO、进程线程事件放在一个统一的框架下进行管理。如果有其他的事件触发需求也可以改libev源码把该事件加入libev的框架中（当前前提是得理解libev的设计）。有文章说libev性能比libevent好，没实验过，但是从源码角度看，libev要更简洁，当然更费解一点。作者为了追求代码的整洁和统一使用了大量的宏，造成了阅读的不便。这里我们从宏观分析一下libev的设计实现，然后穿插分析一些小的trick。旨在学习总结libev设计中优雅的地方。</p>

<h3>基本概念</h3>

<p class="indent">首先是一些主要的概念和数据结构。</p>

<p class="indent">libev通过定义watcher来关注一个事件，并且把事件类型和对应的毁回调函数关联起来。libev定义了多种事件类型，同时可以在框架中自己添加感兴趣的事件，libev保证了事件触发的顺序性，并在多线程环境下保证事件的串行触发。</p>

<p class="indent">每一种类型的watcher都包含几个基本的成员，通过EV_WATCHER和EV_WATCHER_LIST宏实现。EV_WATCHER_LIST比EV_WATCHER多了一个纸箱下一个watcher的指针。EV_WATCHER_TIMER是定时器的基类，多一个timestamp。这几个宏这里留一个小的trick分析，在后面阐述。</p>

</div>


    <footer>
      <a rel="full-article" href="/2015/12/19/libev-source-analysis/">阅读全文</a>
    </footer>



    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2015/11/01/ssh-bind-other-port/">Ssh绑定其他端口</a></h1>


      <p class="meta">














<time datetime="2015-11-01T14:14:00+08:00" pubdate data-updated="true">Nov 1<span>st</span>, 2015</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">首先修改/ssh/sshd_config，把Port 22解注释，然后加一行Port xx。之后修改 /etc/sysconfig/iptables，加入该端口的Rules:</p>

<pre><code>-A INPUT -m state --state NEW -m tcp -p tcp --dport xx -j ACCEPT
</code></pre>

<p class="indent">重启即可。</p>

<pre><code>/etc/init.d/sshd restart
</code></pre>

<p class="indent">这么做的目的是如果出现问题，还有一个端口可以上去修改。登录的时候需要对应的指定一下端口：</p>

<pre><code>ssh -p xx user@host
scp -P xx ... user@host
</code></pre>

<p class="indent">补充两个SSH技巧：</p>

<ol>
<li><p> 客户端配置中转，主要是通过跳板机登录：</p>

<pre><code>Host xx
HostName 192.168.1.1
User xx
ProxyCommand ssh -q xxx@login2.xxx.xx nc %h %p
</code></pre></li>
<li><p> 保持会话。 ssh会在.ssh目录下生成一个会话选项，下次登录同一个server公用会话，不需要验证。</p>

<pre><code>Host *
ControlMaster auto
ControlPath ~/.ssh/master-%r@%h:%p
</code></pre>

<p>上面会话共享，所以不能关闭会话。可以通过 <code>ssh -fN xxx</code> 把第一个会话放到后台不退出</p></li>
</ol>

</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2015/08/31/rbtools-compatible-problems/">RBTools兼容的问题</a></h1>


      <p class="meta">














<time datetime="2015-08-31T15:26:00+08:00" pubdate data-updated="true">Aug 31<span>st</span>, 2015</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">某天ReviewBoard客户端突然用不了，使用    <code>rbt post</code>的时候报错:</p>

<pre><code>from six.moves.urllib.parse import quote
ImportError: No module named urllib.parse
</code></pre>

<p class="indent">乍一看以为什么包被卸载了。于是pip install six &mdash;upgrade，无果。pip uninstall RBTools再重新安装RBTools，也无效。</p>

<p class="indent">查了一下six是python2、python3的兼容包，直接修改源码，不要兼容了，发现用到的地方好多，改不过来（ps，兼容python2、python3真不容啊）。</p>

<p class="indent">查看six的版本，发现跟本地一样的，本地没什么问题。说明不是six的问题。直接在命令行from six.moves.urllib.parse import quote，发现本地ok，服务器上不行。</p>

<p class="indent">这就比较扯了，同样的版本，本地可以服务器不行。直接卸了重装：</p>

<pre><code>pip uninstall six #注，这里卸载了1.9的six
pip uninstall six #日，还有一个1.2的six，不知道pip list为啥显示不出来。
pip install six
easy_install RBTools
</code></pre>

<p class="indent">然后就ok了。所以还是要习惯在virtualenv下搞啊&hellip;</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2015/08/28/paxos-case-analysis/">Paxos的一些case分析</a></h1>


      <p class="meta">














<time datetime="2015-08-28T11:34:00+08:00" pubdate data-updated="true">Aug 28<span>th</span>, 2015</time>

      </p>

  </header>


  <div class="entry-content"><p>acceptor: a([epoc:4, value:n])  b[epoc:3,value:y]  c[epoc:6,:value:y]</p>

<p>proposor:  x5, x7,   (x4, x3, x6)</p>

<p>prepare:x5[a, b], x7[b, c]</p>

<p>commit:x[4,n] y[6, y]</p>

<p>一共有5个proposer,</p>

<p>1）初始时 x4 (prepare)&ndash;> a, x3 (prepare)&ndash;> b,x6 (prepare)&ndash;> c,
2） x4, x3, x6 挂掉
3）x5(prepare)&ndash;> a, b
4）x5(commit[epoc:4, value:n])&ndash;>a, b
5) x7(prepare) &ndash;>b, c
6) x7(commit[epoc:6, value:y])&ndash;>b, c</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2015/08/23/gitbook-guide/">Gitbook使用指导</a></h1>


      <p class="meta">














<time datetime="2015-08-23T16:23:00+08:00" pubdate data-updated="true">Aug 23<span>rd</span>, 2015</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">gitbook是nodejs实现的用来帮助书写电子书的，很多开源的书籍项目是基于gitbook的。gitbook的编写语言是markdown，书籍遵循一定的格式完成之后可以通过gitbook发布为各种版本，比如pdf，mobi等电子书格式，或者发布为静态的website，挂到github pages上，对于一些开源项目来说，这是很方便的书写帮助文档的方式。gitbook同样有一个<a href="https://www.gitbook.com/" title="A modern publishing toolchain. Simply taking you from ideas to finished, polished books.">paas的平台</a>，可以允许多人协作在线完成一部电子书</p>

<p class="indent">首先安装gitbook</p>

<pre><code>npm -g install gitbook
npm -g install gitbook-cli
npm -g install ebook-convert
</code></pre>

<p class="indent">第三个是安装生成电子书的插件，但是这里并不会安装bin文件，需要手动安装<a href="http://calibre-ebook.com/" title="calibre: The one stop solution for all your e-book needs. Comprehensive e-book software.">Calibre</a>。Mac下可以安装Calibre的app然后链接一下bin：</p>

<pre><code>ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin
</code></pre>

<p class="indent">这样就可以生成pdf/mobi等格式的电子书了。</p>

<p class="indent">使用方式可以通过gitbook help来查看。主要是如下几个：</p>

<pre><code>gitbook build [book] [output]   生成电子书，通过--format指定输出格式，默认输出为website
gitbook pdf [book] [output]     生成pdf电子书
gitbook epub [book] [output]    生成epub电子书
gitbook mobi [book] [output]    生成mobi电子书
serve [book]                    生成并开启http server预览
init [directory]                根据summary建立基本目录结构
install [book]                  安装依赖和插件
</code></pre>

<p class="indent">Summary的基本样子见这里：</p>

<pre><code># Summary
* [Introduction](README.md)
* [入门](getting_started/README.md)
   * [初识](getting_started/what_is_it.md)
   * [安装](getting_started/installing_es.md)
   * [API](getting_started/api.md)
   * [文档](getting_started/document.md)
   * [索引](getting_started/tutorial_indexing.md)
   * [搜索](getting_started/tutorial_search.md)
   * [汇总](getting_started/tutorial_aggregations.md)
   * [小结](getting_started/tutorial_conclusion.md)
   * [分布式](getting_started/distributed.md)
   * [本章总结](getting_started/conclusion.md)
* [分布式集群](distributed_cluster/README.md)
</code></pre>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2015/08/07/work-anniversary-note/">工作周年总结</a></h1>


      <p class="meta">














<time datetime="2015-08-07T15:50:00+08:00" pubdate data-updated="true">Aug 7<span>th</span>, 2015</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">工作两周年了，感觉这两年走了不少弯路，也学到不少东西，最近看到日照的<a href="http://www.nosqlnotes.net/archives/128" title="2010年度总结">周年总结</a>，觉得也应该写写。而且看看日照当时的情况，觉得跟我现在也差不多，同样处在职业的选择期，一个明确的规划还是很重要的。</p>

<h3>总结</h3>

<p class="indent">2013年进入支付宝Oceanbase组，待了一年半的时间吧，第一年主要在0.5上修修改改，第二年换到了UPS组，参与1.0的设计。从第一年的情况看，基本是完成了一个不错的职业素养培训，有了分布式的基本概念，处于了解熟悉的阶段。第二年开始对分布式协议有了一些认识，算是入门了吧。总结两年还是学到了一些东西，但是也算是付出了一些代价。出来之后看之前的组，觉得对应届生还是个不错的选择，ob有点像一个学校，闲的时候有不错的学习机会，就是加班太多了。</p>

<p class="indent">后来身体原因离职，来搜狐大数据中心，开始做推荐系统相关的东西。从那个时候想做算法，搞了半年多吧，有些了解，不算入门，大概处于这样一个状态。对我来说，兴趣总归是第一位的，然而在一个方向上有所积累更重要。这样容易过了几年发现什么都会点什么都不精通。互联网发展这么快，</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2015/07/30/log4cxx-setup/">Log4cxx安装</a></h1>


      <p class="meta">














<time datetime="2015-07-30T15:55:00+08:00" pubdate data-updated="true">Jul 30<span>th</span>, 2015</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">log4cxx是apache基金会的log开源项目，log4j的c++实现，安装的时候遇到一个小问题：</p>

<p class="indent">首先正常安装：</p>

<pre><code>wget http://mirrors.cnnic.cn/apache/logging/log4cxx/0.10.0/apache-log4cxx-0.10.0.tar.gz
tar zxvf apache-log4cxx-0.10.0.tar.gz
cd apache-log4cxx-0.10.0
./configure
make
</code></pre>

<p class="indent"> 报错libdb-4.3.so 格式错误。开始以为是文件损坏了，查了一下这个文件</p>

<pre><code>yum provides */libdb-4.3.so
</code></pre>

<p class="indent"> 提示在db4里面，重新安装db4</p>

<pre><code>yum reinstall db4
</code></pre>

<p class="indent"> 回去还是报错。后来看了一下格式，貌似链接到了32位版本。修改软连接：</p>

<pre><code>cd /usr/lib/
rm libdb-4.3.so
ln -s ../../lib64/libdb-4.3.so .
</code></pre>

<p class="indent"> 同样处理另外一个库</p>

<pre><code>rm libexpat.so
ln -s ../../lib64/libexpat.so.0.5.0 libexpat.so
</code></pre>

<p class="indent"> 应该就OK了。</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2015/07/29/group-commit/">关于group Commit</a></h1>


      <p class="meta">














<time datetime="2015-07-29T17:25:00+08:00" pubdate data-updated="true">Jul 29<span>th</span>, 2015</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">最近突然想到这个东西，以前Oceanbase的UpdateServer提交的时候是做了group commit的。基本思路如下：</p>

<ol>
<li> 并发小的时候，超过一个时间窗口就直接提交</li>
<li> 并发大的时候，等请求填满一个buffer再一起提交。</li>
</ol>


<p class="indent">实现上可以考虑如下伪代码：</p>

<pre><code>while true:
    start timer
    if buffer full or timer reach limit:
        commit
        reset timer
    else
        wait and receive
</code></pre>

<p class="indent">广泛运用在一些需要组合请求的地方，比如一些rpc因为历史原因（嗯）一直单条请求，不能改协议的情况下，可以考虑转发一下，做个缓冲。当然这种情况下一般是通过队列来缓冲请求压力。</p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2015/07/28/something-about-guide-a-team/">带小团队的一点思考</a></h1>


      <p class="meta">














<time datetime="2015-07-28T13:56:00+08:00" pubdate data-updated="true">Jul 28<span>th</span>, 2015</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">事实上我也只是带实习生而已。但是感觉上之前更多的是把自己的任务分出去，而现在是开始跟一些人一起完成一个任务。主要的不同是之前做的事情是在个人工作量里面，自己做也只是慢一点，有时候甚至自己做反倒比分出去更快。现在做的事情已经超过一个人工作量了，必须发挥团队的能动性了，而且之前也只是对自己的工作负责，现在你要负责的是一个团队的KPI了。</p>

<p class="indent">主要有几点感觉：</p>

<ol>
<li> 分配好工作。需要能力的，需要经验的，需要稳定细心的，每个人的风格不一样，应该做的工作也不一样。</li>
<li> 规范流程。大部分加班或者事故都是能从流程上避免的，在设计开发测试上省下来的时间最终都会在上线修bug处理问题的过程中补回来。</li>
<li> 做好计划和项目管理。做一个包含不确定性和风险的事情最重要的是路线图。实现的过程就是把抽象的东西一点点具象化的过程。所以计划上要能够自顶向下，逐步求精。把写程序的思路用进来。</li>
<li> 最后就是能力的问题了。统筹考虑是种需要一点点培养的能力。这个也就只能慢慢来了。何况只要不是纯做管理，你就一定有自己的工作，自己的KPI，协调好自己工作和他人工作安排的关系，还是非常重要的。</li>
</ol>


<p class="indent">最后补一个我理解的开发流程图：</p>

<p class="indent"><img class="img-polaroid center" src="/images/2015/dev-flow.png"></p>
</div>




    </article>


    <article class="well">

  <header class="page-header">

      <h2 class="entry-title"><a href="/2015/07/18/build-topic-tree-using-parent-relation/">通过父子关系构建话题树</a></h1>


      <p class="meta">














<time datetime="2015-07-18T11:35:00+08:00" pubdate data-updated="true">Jul 18<span>th</span>, 2015</time>

      </p>

  </header>


  <div class="entry-content"><p class="indent">一道题目，本来觉得挺简单的，后来卡在一个小问题上。mark一下：</p>

<p class="indent">给定一个数据库表，存了所有话题的关系，形式是：parent->child，表示前面是后面话题的父话题。根据这个关系构建出话题树并打印。</p>

<pre><code>eg:
输入：
    a b
    c a
    d e
    e f
    r c
    r d
输出：
     r
       c
         a
           b
       d
         e
           f
题目隐含：
    1. DAG：有向无环
    2. 节点不重复
</code></pre>

<p class="indent">直观看类似于Graphviz的算法，只不过保证了是棵树。C++实现上可以直接通过树来做，这里用了Python。</p>

</div>


    <footer>
      <a rel="full-article" href="/2015/07/18/build-topic-tree-using-parent-relation/">阅读全文</a>
    </footer>



    </article>

  <ul class="pager">

    <li class="previous"><a href="/page/2/">&larr; Older</a></li>

    <li><a href="/blog/archives">Blog Archives</a></li>

  </ul>
</div>
<aside class="sidebar-nav span3">

    <section class="well">
    <div class="profilepic align-center">
        <img src="/images/common/cxh.jpeg" alt="cxh.me" width="160px" class="img-rounded"/>
    </div>
    <hr/>

    <ul id="about_me" class="nav nav-list">
        <li class="nav-header">About Me</li>
        <li class="sindent">北航本，清华硕，先后就职于支付宝北京、搜狐大数据中心、美团云。方向分布式数据库系统、分布式文件系统、推荐/广告系统。</li>
    </ul>
</section>
<section class="well">
    <ul id="profile" class="nav nav-list">
        <li class="nav-header">Profile</li>
        <li><a href="https://github.com/chenxiaohui/">GitHub</a></li>
        <li><a href="https://gitcafe.com/chenxiaohui/">GitCafe</a></li>
        <li><a href="http://weibo.com/sdqxcxh/">Weibo</a></li>
        <li><a href="https://twitter.com/sdqxcxh/">Twitter</a></li>
        <li><a href="https://facebook.com/sdqxcxh/">Facebook</a></li>
        <li><a href="http://www.zhihu.com/people/chen-xiao-hui-63">Zhihu</a></li>
    </ul>
</section>
<section class="well">
    <ul id="refs" class="nav nav-list">
        <li class="nav-header">Blogroll</li>
        <li><a href="http://blog.codinghonor.com/">赵龙的博客</a></li>
        <li><a href="http://yiguid.com/">大顾的博客</a></li>
        <li><a href="http://www.chunhuiwang.com">Charles Wang 的传说</a></li>
        <li><a href="http://wukan.me/">阿倫的孤獨星球</a></li>
        <li><a href="http://www.yuzelang.com/">狼的博客</a></li>
    </ul>
</section>
<section class="well">
    <ul id="feeling" class="nav nav-list">
        <li>
            <img src="/images/common/baiyipiaopiao.jpg" class="notice_pic img-polaroid" alt="notice" />
        </li>
        <hr/>
        <li>
            还是走吧甩一甩头<br/>在这夜凉如水的路口<br/>那唱歌的少年<br/>已不在风里面<br/>你<br/>还在怀念
            <p class="align-right">
            ———那白衣飘飘的年代
            </p>
        </li>
    </ul>
</section>
<section class="well">
  <ul id="recent_posts" class="nav nav-list">
    <li class="nav-header">Recent Posts</li>

      <li class="post">
        <a href="/2017/04/04/summarize-of-recently-days/">总结下最近的生活</a>
      </li>

      <li class="post">
        <a href="/2016/07/04/gcc-printf-format-attribute/">gcc的格式化字符串检查</a>
      </li>

      <li class="post">
        <a href="/2016/06/28/search-log-with-timcat/">用timecat来定位日志</a>
      </li>

      <li class="post">
        <a href="/2016/06/20/pypython-is-an-eggache-language/">python是一门蛋疼的语言</a>
      </li>

      <li class="post">
        <a href="/2016/06/18/ccache-and-cgo/">ccache和cgo并存的问题</a>
      </li>

      <li class="post">
        <a href="/2016/06/17/export-disk-using-nfs/">使用nfs挂载网络磁盘</a>
      </li>

      <li class="post">
        <a href="/2016/06/13/safe-spin-lock/">跨线程解锁安全的spinlock</a>
      </li>

      <li class="post">
        <a href="/2016/06/06/glibc-no-symbol-problem/">有关coredump没有符号的问题</a>
      </li>

      <li class="post">
        <a href="/2016/05/26/union-struct-initialize/">union和struct相互嵌套时的初始化</a>
      </li>

      <li class="post">
        <a href="/2016/05/18/loglogrotate-version-problem/">logrotate版本问题</a>
      </li>

  </ul>
</section>


</aside>

    </div>
  </div>
  <footer role="contentinfo" class="page-footer"><hr>
<p>
  Copyright &copy; 2017 - Harry Chen - <a href="http://www.miitbeian.gov.cn/" title="备案">京ICP备17017883号-1</a>
  <span class="credit">
      Powered by <a href="http://octopress.org">Octopress</a> /
                 <a href="http://getbootstrap.com/2.3.2/">Bootstrap</a> -
  </span>
  <span class="credit"><!--Statistics-->
 </span>
</p>


<script src="//upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.0.min.js"></script>
<script src="//upcdn.b0.upaiyun.com/libs/modernizr/modernizr-2.6.1.min.js"></script>
<script src="//cdn.bootcss.com/bootstrap/2.3.2/js/bootstrap.js"></script>

<script src="/javascripts/octopress.js" type="text/javascript"></script>

</footer>


<script type="text/javascript">
      var disqus_shortname = 'harrychen';


        var disqus_script = 'count.js';

    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>








<link href="/javascripts/google-code-prettify/prettify.css" media="screen, projection" rel="stylesheet" type="text/css">
<script type="text/javascript" src="/javascripts/google-code-prettify/prettify.js"></script>
<script type="text/javascript" >
<!--
    $(document).ready(function() {
      $('pre').addClass('prettyprint').attr('style', 'overflow:auto');
      window.prettyPrint && prettyPrint();
      $('table').addClass('table')
});
-->
</script>


</body>
</html>
